%
% vim: foldlevel=1
%
\documentclass{beamer}


\mode<presentation>
{
  \usetheme[compress]{Ilmenau}
	\useinnertheme{circles}
	\usecolortheme{lostrace}
  \setbeamercovered{transparent}
  \setbeamertemplate{navigation symbols}{}
}

%\usepackage{epsfig,graphicx,epsf}
\usepackage{pgfbaseimage}
%\usepackage[ngerman]{babel}
%\usepackage{ucs}
%\usepackage[utf8x]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{multimedia}
\usepackage{listings}

\newenvironment{itemizeframe}[1]
  {\begin{frame}{#1}\startitemizeframe}
  {\stopitemizeframe\end{frame}}
\newcommand\startitemizeframe{\begin{itemize}}
\newcommand\stopitemizeframe{\end{itemize}}



\title[Targeting Physically Addressable Memory]
{ { \small DIMVA 2007, Lucerne} \\ \textbf{Targeting Physically Addressable Memory}}

\author[David R. Piegdon and Lexi Pimenidis]
{David~Rasmus~Piegdon \\ {\tiny <david.rasmus.piegdon@rwth-aachen.de>} \\ Lexi Pimenidis \\ {\tiny <lexi@i4.informatik.rwth-aachen.de>}}

\institute[RWTH Aachen University of Technology]{
	Lehrstuhl f\"ur Informatik IV, RWTH Aachen\\ {\tiny \ \\ http://www-i4.informatik.rwth-aachen.de \\} 
}

\date[2007-07-13]
{July 13th 2007}

\subject{Direct Memory Access hacking}

%\pgfdeclareimage[height=0.4cm]{by-nc-sa}{../bilder/by-nc-sa}
%\titlegraphic{\href{http://creativecommons.org/licenses/by-nc-sa/2.0/de/}{\pgfuseimage{by-nc-sa}}}

\pgfdeclareimage[interpolate=true,height=1.0cm]{i4-1394}{i4_ieee1394_stacked}
\logo{\pgfuseimage{i4-1394}}

\pgfdeclareimage[interpolate=true,height=1.0cm]{logo-1394}{ieee1394-logo-big}
\pgfdeclareimage[interpolate=true,height=6.7cm]{ia32-vm}{ia32_segmentation_paging}
\pgfdeclareimage[interpolate=true,height=6.0cm]{linux-ia32-vmlayout}{linux_virtual_address_space}
\pgfdeclareimage[interpolate=true,width=10.0cm]{beachhead}{functionality_beachhead}

%\pgfdeclareimage[height=3cm]{microkernel}{microkernel}
%\pgfdeclareimage[height=6cm]{monolith}{monolith}
%\pgfdeclareimage[height=19cm]{kernel-attackspace}{kernel-attackspace}


\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Table of Contents}
	\tableofcontents[hideallsubsections]
\end{frame}

\AtBeginSection{
%	\begin{frame}
%	  \frametitle{Table of Contents}
%	  \tableofcontents[hideallsubsections]
%	  % Die Option [pausesections] könnte nützlich sein.
%	\end{frame}
	\begin{frame}<beamer>
		\frametitle{Table of Contents}
		\tableofcontents[current,hideallsubsections]
	\end{frame}
}

% "` "'
% umlaute "a ...

% \begin{exampleblock}	gruene box
% \begin{alertblock}	rote box
% \begin{Definition}	blaue box, titel "Definition"
% \begin{Example}	gruene box, titel "Example"
% \alert{...}		roter text
% \structure{...}	blauer text

\section{Accessing memory}

	\subsection{Methods}

		\begin{frame} \frametitle{Methods}
			Many ways to gain access to memory:
			\begin{itemize}
				\item special PCI cards (forensic, remote management cards)
				\item special PCMCIA cards
				\item FireWire (IEEE1394) DMA feature
				\item anything with DMA
				\item Linux \texttt{/dev/mem}
				\item memory dumps
				\item Suspend2Disk images
				\item Virtual machines
				\item \ldots
			\end{itemize}
		\end{frame}

	\subsection{DMA hardware}

		\begin{frame} \frametitle{FireWire overview}
			\pgfuseimage{logo-1394} FireWire a.k.a. iLink a.k.a. IEEE1394
			\begin{itemize}
				\item Hot-pluggable
				\item Wide-spread (even among laptops)
				\item Expansion Bus (like PCI or PCMCIA)
				\item Has DMA (if enabled by driver)
%				\item Guaranteed bandwith feature
%				\item Used alot for media-crunching
				\item Most people are not aware of abuse-factor
			\end{itemize}
		\end{frame}

	\subsection{DMA software}

		\begin{itemizeframe}{\texttt{/dev/mem}}
			\item Gives access to physically addressed memory
			\item Shall be obsoleted in future (X shall use DRI)
			\item Only gives access to \structure{lower 896MB} RAM (only these are mapped)
		\end{itemizeframe}

	\subsection{Problems and Countermeasures}

		\begin{itemizeframe}{Generic problems of DMA attacks}
			\item Swapping
			\item Multiple accessors at any time
			\item Caching
		\end{itemizeframe}
		
		\begin{frame} \frametitle{Countermeasures against DMA}
			Several approaches, both to hide malware from forensics and to protect memory from DMA attacks:

			\begin{itemize}
				\item Keep stealth code/data only in CPU cache (?)
				\item Redirect CPU via MTTR/IORR registers [9]
				\item Redirect DMA via NorthBridge (IOMMU) [9]
			\end{itemize}

		\end{frame}

	\subsection{\texttt{libphysical}}

		\begin{itemizeframe}{One interface to access any source}
			\item One generic interface: \texttt{libphysical}
			\item Backends for any source
			\item Implemented so far:
			\begin{itemize}
				\item Filedescriptor (\texttt{/dev/mem}, memory dumps)
				\item FireWire
			\end{itemize}
		\end{itemizeframe}


\section{Virtual address spaces}

	\subsection{Virtual address spaces}

		\begin{itemizeframe}{What now?}
			\item Once we got access\ldots
				we can see a bunch of random memory

			\item \structure{How does OS manage memory?}
				\begin{itemize}
					\item Parse kernel structures (depends on Arch,OS+Version)
					\item Parse virtual address spaces (depens on Arch)
				\end{itemize}
		\end{itemizeframe}

		\begin{frame} \frametitle{IA-32}
			\begin{itemize}
				\item IA-32 provides \structure{Segmentation} (required) and \structure{Paging} (optional)
				\item Linux only uses paging $\rightarrow$ all segments flat

				\item Hardware needs to know how to translate:
				\begin{itemize}
					\item Global Descriptor Table (GDT) (segmentation)
					\item Local Descriptor Table (LDT) (segmentation)
					\item Page Directory (PD)
					\item Page Tables (PT) (referenced by PD)
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame} \frametitle{IA-32 virtual (``logical'') address translation}
			\pgfuseimage{ia32-vm} ~~(from [6])
		\end{frame}

	\subsection{Finding Address Translation Tables}
		
		\begin{frame} \frametitle{Finding ATTs}
			Address Translation Tables (including PDs)\ldots
			\begin{itemize}
				\item depend on \structure{architecture}
				\item depend on \structure{operating system}
				\item may have recognisable patterns
			\end{itemize}
			$\rightarrow$ create simple signature for (arch, OS). so far:
			\begin{itemize}
				\item (i386, Linux 2.4 and 2.6)
				\item (i386, Windows XP)
			\end{itemize}
			$\rightarrow$ Finding an ATT:
			\begin{itemize}
				\item Check for simple pattern AND do statistical test (NCD)
			\end{itemize}
		\end{frame}

		\begin{itemizeframe}{Normalized Compression Distance}
			\item \structure{N}ormalized \structure{I}nformation \structure{D}istance:
			\begin{itemize}
				\item Minimal amount of changes required between two information
				\item Uses \structure{Kolmogorov Complexity} (KC) (size of minimal representation of information)
				\item Incalculable
			\end{itemize}
			\item KC can be \structure{approximated} by \structure{compressor} \\
				$\rightarrow$ \structure{N}ormalized \structure{C}ompression \structure{D}istance:
			\begin{itemize}
				\item Calculable
				\item Very versatile (parameter-free)
				\item e.g. create relational trees of gene-sequences [4]
				\item or \emph{Analyzing Worms and Network Traffic using Compression}, Stephanie Wehner, 2006
			\end{itemize}
		\end{itemizeframe}

		\begin{frame}
			\frametitle{\texttt{liblinear}}

			Translation by hand:
			\begin{itemize}
				\item Implementation in software in \texttt{liblinear}. So far:
				\begin{itemize}
					\item IA-32 Protected Mode, without PAE36 \\ (Linux with $\leq 4$GB RAM)
				\end{itemize}
				\item Well-defined algorithm for architecture, e.g. for IA-32: [6]
				\item emulates \texttt{/dev/kmem} on the fly
				\item $\rightarrow$ also for forensics
			\end{itemize}
		\end{frame}

\section{Gathering information}

	\begin{frame}
		So far
		\begin{itemize}
			\item We can \structure{access physical memory sources} in a generic way (\texttt{libphysical})
			\item We can find and \structure{access virtual address spaces} of processes (\texttt{liblinear})
		\end{itemize}
		Now we want to \structure{identify} processes we found.
	\end{frame}

	\subsection{Identifying Processes}
	
		\begin{frame}[fragile]
			\begin{verbatim}
				#include <stdio.h>

				int main(int argc, char**argv)
				{
				    printf("my name is %s\n", argv[0]);
				    return 0;
				}
			\end{verbatim}
			\begin{itemize}
				\item \texttt{argv}, \texttt{envv} are on the stack (first mapped pages below page \texttt{0xc0000})
				\item NUL-separated vector with
				\begin{itemize}
					\item Path of binary
					\item Environment
					\item Arguments
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]
			\scriptsize
			\begin{semiverbatim}
			# OLDPWD=/home/lostrace PWD=/home/lostrace/documents/rwth/SEAT\ \\
			\ \ /attacks/userspace SHLVL=1 _=./victim \ \\
			\ \ ./victim {-}{-}arg=foo bar {-}{-}baz

			0xbfc5ff70  00 00 \textcolor{green}{00 00} 2e 2f 76 69  |..\textcolor{green}{..}./vi|    ARGV[]:
			0xbfc5ff78  63 74 69 6d \textcolor{red}{00} 2d 2d 61  |ctim\textcolor{red}{.}{-}{-}a|      [0] = bfc5ff74
			0xbfc5ff80  72 67 3d 66 6f 6f \textcolor{red}{00} 62  |rg=foo\textcolor{red}{.}b|      [1] = bfc5ff7d
			0xbfc5ff88  61 72 \textcolor{red}{00} 2d 2d 62 61 7a  |ar\textcolor{red}{.}{-}{-}baz|      [2] = bfc5ff87
			0xbfc5ff90  \textcolor{red}{00} 4f 4c 44 50 57 44 3d  |\textcolor{red}{.}OLDPWD=|      [3] = bfc5ff8b
			0xbfc5ff98  2f 68 6f 6d 65 2f 6c 6f  |/home/lo|      [4] = NULL
			0xbfc5ffa0  73 74 72 61 63 65 \textcolor{red}{00} 50  |strace\textcolor{red}{.}P|
			0xbfc5ffa8  57 44 3d 2f 68 6f 6d 65  |WD=/home|
			0xbfc5ffb0  2f 6c 6f 73 74 72 61 63  |/lostrac|
			0xbfc5ffb8  65 2f 64 6f 63 75 6d 65  |e/docume|
			0xbfc5ffc0  6e 74 73 2f 72 77 74 68  |nts/rwth|
			0xbfc5ffc8  2f 53 45 41 54 2f 61 74  |/SEAT/at|
			0xbfc5ffd0  74 61 63 6b 73 2f 75 73  |tacks/us|
			0xbfc5ffd8  65 72 73 70 61 63 65 \textcolor{red}{00}  |erspace\textcolor{red}{.}|
			0xbfc5ffe0  53 48 4c 56 4c 3d 31 \textcolor{red}{00}  |SHLVL=1\textcolor{red}{.}|
			0xbfc5ffe8  5f 3d 2e 2f 76 69 63 74  |_=./vict|
			0xbfc5fff0  69 6d \textcolor{red}{00} 2e 2f 76 69 63  |im\textcolor{red}{.}./vic|
			0xbfc5fff8  74 69 6d \textcolor{green}{00 00 00 00 00}  |tim\textcolor{green}{.....}|
			\end{semiverbatim}
		\end{frame}

		\begin{itemizeframe}{Finding Specific Processes}
			\item[1] Find all virtual address spaces
			\item[2] For each: look if binary matches searched binary
			\begin{itemize}
				\item \texttt{/usr/lib/mozilla-firefox/firefox-bin}
				\item \texttt{/usr/bin/gpg}
				\item \texttt{/usr/bin/ssh-agent}
			\end{itemize}
			\item[3] If matches, steal a cookie or\ldots \uncover<2->{a ssh-private key}
		\end{itemizeframe}

	\subsection{Secrets}

		\begin{frame} \frametitle{Stealing SSH private keys}
			\structure{Let's get dangerous!}

			Steal SSH private key from \texttt{ssh-agent}:

			\begin{itemize}
				\item agent keeps key decrypted, locked in memory
				\item has timeout-function to wipe keys from memory
				\item stalled in \texttt{read()}-syscall on socket
				\item \alert{no timer} to check for timeout (Fixed by now)
				\item checks timer only on query (Fixed by now)
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]
			\begin{semiverbatim}
				typedef \textcolor{green}{struct identity} \{
				\ \ 	Key *key;
				\ \ 	char *\textcolor{blue}{comment};  
				\ \           \structure{(key filename: ``\$HOME/.ssh/id\_rsa)''}
				\ \ 	u_int death;
				\} Identity;

				\textcolor{green}{struct Key} \{
				\ \ 	int      type;
				\ \ 	int      flags;
				\ \ 	RSA     *rsa;
				\ \ 	DSA     *dsa;
				\};
			\end{semiverbatim}
		\end{frame}

	\subsection{resume}

		\begin{itemizeframe}{Resume}
			\item So far: only \structure{read} memory.
			\item Works with memory dumps
			\item No time to prepare an attack?
			\item $\rightarrow$ Just dump memory and do it later
		\end{itemizeframe}

\section{Injecting code}

%	\begin{itemizeframe}{Attacking by Writing}
%		\item The pen is mightier than the sword.
%		\item No more sword to be feared than the learned pen.
%		\item Even the virtual one.
%	\end{itemizeframe}

	\subsection{Injecting the code}

		\begin{itemizeframe}{Inject where?}
			\item Cannot allocate memory for code
			\item Cannot overflow a buffer (no I/O with process)
			\item Need to \structure{overwrite} code, data or stack
			\item Code: \structure{Shared} objects/executable
			\item Data: can not be easily identified; data may be mapped into multiple processes
		\end{itemizeframe}
			
		\begin{itemizeframe}{Inject into stack}
			\item Stack is easy to find
			\item One stack per thread
			\item Inject into zero-padded pages containing ENV and ARG.
			\item Possibly overwrite these. If so, visible:
			\begin{itemize}
				\item \texttt{/proc/\$PID/environ}
				\item \texttt{/proc/\$PID/cmdline}
			\end{itemize}
			\item execute: manipulate stack frames (checksums? haha!)
		\end{itemizeframe}

	\subsection{Executing the code}

	\subsection{Communicating with shellcode}

		\begin{frame} \frametitle{Rootshell?}
			\begin{itemize}
				\item Royal leage of code-injection: \structure{interactive (root-)shell}
			\end{itemize}
			$\rightarrow$ Inject bindshell
			\begin{itemize}
				\item Network required
				\item Easily found
			\end{itemize}
			$\rightarrow$ Inject shellcode and communicate via IEEE1394
			\begin{itemize}
				\item Big, complex payload (IEEE1394 handling)
				\item Attack via IEEE1394?
			\end{itemize}
			$\rightarrow$ Inject Syscall-Proxy
			\begin{itemize}
				\item Victim, self need to be same Arch, OS, API/ABI
				\item I attacked IA-32 from PPC\ldots
			\end{itemize}
		\end{frame}

		\begin{frame} \frametitle{DMA-Shell}
			\begin{itemize}
				\item Only thing that is for sure: DMA
			\end{itemize}
			$\rightarrow$ Communication via DMA
		\end{frame}
		
%		\begin{itemizeframe}{Beachhead}
%			\item Communicate via two Ringbuffers
%			\item Special shellcode (``beachhead'') creates pipes,
%			\item Forks and child executes shell
%			\item Parent creates second thread
%			\item Two threads, two ringbuffers, two pipes:
%			\item Ringbuffer $\rightarrow$ Reader-Thread $\rightarrow$ Pipe $\rightarrow$ Shell
%			\item Ringbuffer $\leftarrow$ Writer-Thread $\leftarrow$ Pipe $\leftarrow$ Shell
%		\end{itemizeframe}

		\begin{frame}
			Special ``Beachhead'' Shellcode: \\
			\pgfuseimage{beachhead}
		\end{frame}
		
		\begin{itemizeframe}{}
			\item Payload small (536 Bytes, yet big for shellcode)
			\item Independent of attackers arch, OS
			\item Only DMA required
		\end{itemizeframe}


\section{Prospects, Conclusion}

	\subsection{Prospects}
		\begin{itemizeframe}{Prospects}
			\item Kernelspace Modifications:
			\begin{itemize} 
				\item Shellcode that injects LKM?
				\item Live kernel patching?
			\end{itemize}
			\item Bootstrapping custom operating systems
		\end{itemizeframe}

	\subsection{Conclusion}

		\begin{itemizeframe}{Conclusion}
			\item DMA attacks are mature
			\item Access to memory $\rightarrow$ security=0
			\item Keep your firewire-ports secured
			\item Some of the tools (\texttt{libphysical}, \texttt{liblinear}) can also be used for forensics
		\end{itemizeframe}

\AtBeginSection{ }

\section*{}

	\begin{frame}
		\begin{center}
			\Large
			Questions? \\[1.5ex]
			
			Thank you for your attention! \\[1.5ex]
			
			\small
			Paper/Tools have been released at \\
			\textcolor{blue}{http://david.piegdon.de/products.html}
			\\[1.5ex]

			\tiny
			Thanks to Maximillian Dornseif, Christian N. Klein, Michael Becher, Timo Boettcher, Alexander Neumann, Swantje Staar and the Chaos Computer Club Cologne
		\end{center}
	\end{frame}

	\begin{itemizeframe}{References (FireWire, DMA Attacks)}
		\item[1] \emph{Michael Becher, Maximillian Dornseif, and Christian N.
			Klein.} \structure{Firewire - all your memory are belong to us}. 2005.

		\item[2] \emph{Adam Boileau.} Hit by a bus: Physical access attacks with
			firewire. Ruxcon 2006.

		\item[3] \emph{Mariusz Burdach.} Finding digital evidence in physical memory. 2006.
	\end{itemizeframe}

	\begin{itemizeframe}{References}
		\item[4] \emph{Rudi Cilibrasi and Paul M. B. Vit\'anyi.} Clustering by compression.
			IEEE transactions on information theory, vol. 51, 2005.

		\item[5] \emph{Otto Spaniol et al.} Systemprogrammierung, Skript zur Vorlesung an der RWTH
			Aachen. Wissenschaftsverlag Mainz; Aachener Beitraege zur Informatik (ABI),
			2002. ISBN 3-86073-470-9.
			
		\item[6] \emph{Intel Corp.} Intel 64 and IA-32 Architectures Software Developers Manual.
	\end{itemizeframe}

	\begin{itemizeframe}{References}
		\item[7] \emph{Bruce Schneier.} Applied Cryptography (Second Edition). John Wiley \& Sons,
			Inc, 1996. ISBN 0-471-11709-9.
		\item[8] \emph{John Viega and Matt Messier and Pravir Chandra.} Network Security with
			OpenSSL. O'Reilly, 2002. ISBN 0-596-00270-X.
		\item[9] \emph{Joana Rutkowska.} Beyond The CPU: Defeating Hardware Based RAM Acquisition Tools (Part I: AMD case)
	\end{itemizeframe}

\end{document}

