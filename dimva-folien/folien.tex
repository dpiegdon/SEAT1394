%
% vim: foldlevel=1
%
\documentclass{beamer}


\mode<presentation>
{
  \usetheme[compress]{Ilmenau}
	\useinnertheme{circles}
	\usecolortheme{lostrace}
  \setbeamercovered{transparent}
  \setbeamertemplate{navigation symbols}{}
}

%\usepackage{epsfig,graphicx,epsf}
\usepackage{pgfbaseimage}
%\usepackage[ngerman]{babel}
%\usepackage{ucs}
%\usepackage[utf8x]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{multimedia}
\usepackage{listings}

\newenvironment{itemizeframe}[1]
  {\begin{frame}{#1}\startitemizeframe}
  {\stopitemizeframe\end{frame}}
\newcommand\startitemizeframe{\begin{itemize}}
\newcommand\stopitemizeframe{\end{itemize}}



\title[Targeting Physically Addressable Memory]
{ { \small Seminar of Advanced Exploitation Techniques, WS 2006/2007} \\ \textbf{Targeting Physically Addressable Memory}}

\author[David R. Piegdon and Lexi Pimenidis]
{David~Rasmus~Piegdon \\ {\tiny <david.rasmus.piegdon@rwth-aachen.de>} \\ Lexi Pimenidis \\ {\tiny <lexi@i4.informatik.rwth-aachen.de>}}

\institute[RWTH Aachen University of Technology]{
	Lehrstuhl f\"ur Informatik IV, RWTH Aachen\\ {\tiny \ \\ http://www-i4.informatik.rwth-aachen.de \\} 
}

\date[2007-07-13]
{July 13th 2007}

\subject{Direct Memory Access hacking}

%\pgfdeclareimage[height=0.4cm]{by-nc-sa}{../bilder/by-nc-sa}
%\titlegraphic{\href{http://creativecommons.org/licenses/by-nc-sa/2.0/de/}{\pgfuseimage{by-nc-sa}}}

\pgfdeclareimage[interpolate=true,height=1.0cm]{i4-1394}{i4_ieee1394_stacked}
\logo{\pgfuseimage{i4-1394}}

\pgfdeclareimage[interpolate=true,height=1.0cm]{logo-1394}{ieee1394-logo-big}
\pgfdeclareimage[interpolate=true,height=6.7cm]{ia32-vm}{ia32_segmentation_paging}
\pgfdeclareimage[interpolate=true,height=6.0cm]{linux-ia32-vmlayout}{linux_virtual_address_space}
\pgfdeclareimage[interpolate=true,width=10.0cm]{beachhead}{functionality_beachhead}

%\pgfdeclareimage[height=3cm]{microkernel}{microkernel}
%\pgfdeclareimage[height=6cm]{monolith}{monolith}
%\pgfdeclareimage[height=19cm]{kernel-attackspace}{kernel-attackspace}


\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Table of Contents}
	\tableofcontents[hideallsubsections]
\end{frame}

\AtBeginSection{
%	\begin{frame}
%	  \frametitle{Table of Contents}
%	  \tableofcontents[hideallsubsections]
%	  % Die Option [pausesections] könnte nützlich sein.
%	\end{frame}
	\begin{frame}<beamer>
		\frametitle{Table of Contents}
		\tableofcontents[current,hideallsubsections]
	\end{frame}
}

% "` "'
% umlaute "a ...

% \begin{exampleblock}	gruene box
% \begin{alertblock}	rote box
% \begin{Definition}	blaue box, titel "Definition"
% \begin{Example}	gruene box, titel "Example"
% \alert{...}		roter text
% \structure{...}	blauer text

\section{Introduction}

	\subsection{}

		\begin{itemizeframe}{DMA}
			\item DMA = Direct Memory Access
			\item Basic requirement for introduced approach
			\item Known for a long time: attacker has DMA -> \structure{security=0}
				\begin{itemize}
					\item 0wn3d by an iPod $[1]$
					\item and others $[2,3]$
				\end{itemize}
			\item This is a \structure{proof of concept}
		\end{itemizeframe}

\section{Accessing memory}

	\subsection{Methods}

		\begin{frame} \frametitle{Methods}
			Many ways to gain access to memory:
			\begin{itemize}
				\item special PCI cards (forensic, remote management cards)
				\item special PCMCIA cards
				\item FireWire (IEEE1394) DMA feature
				\item anything with DMA
				\item \texttt{/dev/mem} (Linux)
				\item memory dumps
				\item Suspend2Disk images
				\item Virtual machines
				\item \ldots
			\end{itemize}
		\end{frame}

		\begin{itemizeframe}{Generic problems of DMA attacks}
			\item Swapping
			\item Multiple accessors at any time
			\item Caching
		\end{itemizeframe}

	\subsection{DMA hardware}

%		\begin{frame} \frametitle{DMA hardware}
%			Hardware we may use is
%			\begin{itemize}
%				\item expensive
%				\item specially crafted
%				\item selfmade (some)
%				\item rare
%				\item not hot-pluggable (depends)
%				\item \structure{one exception:} FireWire (IEEE1394)
%			\end{itemize}
%		\end{frame}

		\begin{frame} \frametitle{FireWire overview}
			\pgfuseimage{logo-1394} FireWire a.k.a. iLink a.k.a. IEEE1394
			\begin{itemize}
				\item Hot-pluggable
				\item Wide-spread (even among laptops)
				\item Expansion Bus (like PCI or PCMCIA)
				\item Has DMA (if enabled by driver)
%				\item Guaranteed bandwith feature
%				\item Used alot for media-crunching
				\item Most people are not aware of abuse-factor
			\end{itemize}
		\end{frame}

		\begin{itemizeframe}{FireWire DMA}
			\item DMA only enabled if driver says so
			\begin{itemize}
				\item Linux, BSD, MacOSX: by default (can be disabled)
				\item Windows: only for devices that ``deserve'' it (more later)
			\end{itemize}
			\item If DMA -> full access, no restrictions
		\end{itemizeframe}

		\begin{frame} \frametitle{Windows DMA}
			Devices that ``deserve'' DMA on Windows:

			SBP2 (storage) devices, like
			\begin{itemize}
				\item external disks
				\item \structure{iPod} (has a disk, can run Linux)

				\item<2-> SBP2 signature can be faked (via CSR config ROM) [2]
				\item<2-> Copy config ROM from iPod and install it on any system ($\rightarrow$\texttt{1394csrtool})
			\end{itemize}
		\end{frame}
		
	\subsection{DMA software}

		\begin{itemizeframe}{\texttt{/dev/mem}}
			\item Gives access to physically addressed memory (in opposite to \texttt{/dev/kmem})
			\item Often needed by X-server
			\item Shall be obsoleted in future (X shall use DRI)
			\item Only gives access to \structure{lower 896MB} RAM (only these are mapped)
		\end{itemizeframe}

	\subsection{\texttt{libphysical}}

		\begin{itemizeframe}{One interface to access them all}
			\item One generic interface: \texttt{libphysical}
			\item Backends for anything\ldots
			\item Implemented so far:
			\begin{itemize}
				\item Filedescriptor (\texttt{/dev/mem}, memory dumps)
				\item FireWire
			\end{itemize}
		\end{itemizeframe}

	\subsection{Countermeasures}
		
		\begin{frame} \frametitle{Countermeasures against DMA}
			Several approaches to hide parts of memory from DMA:

			\begin{itemize}
				\item Keep malware (code/data) only in CPU cache
				\item Redirect CPU via MTTR/IORR registers [9]
				\item Redirect DMA via NorthBridge [9]
			\end{itemize}

		\end{frame}

\section{Virtual address spaces}

	\begin{itemizeframe}{so what now?}
		\item Once we got access\ldots
			we can see a bunch of random memory

		\item \structure{How does OS manage memory?}
	\end{itemizeframe}

	\begin{frame}
		Could parse kernel data-structures (if found). But they are different for different
		\begin{itemize}
			\item hardware architecture
			\item operating system
			\item OS version
			\item and may not be documented (Windows)
		\end{itemize}
	\end{frame}

	\subsection{Virtual address spaces}

		\begin{frame}{Virtual Address Spaces}
			Or we could do something else\ldots
			\begin{itemize}
				\item Multitasking Operating System
				\item System runs \structure{several processes} ``at once''
				\item \structure{Privilege separation} required (see [5])
				\item Normally done in \structure{hardware}
			\end{itemize}
			\uncover<2->{
				$\rightarrow$ \structure{Each process has own virtual address space}

				$\rightarrow$ Cannot access other processes memory or operating systems memory

				$\rightarrow$ Cannot circumvent protection mechanism
			}
		\end{frame}


		\begin{frame} \frametitle{IA-32}
			\begin{itemize}
				\item IA-32 provides two techniques (that may be chained)
				\begin{itemize}
					\item \structure{Segmentation} (required)
					\item \structure{Paging} (optional)
				\end{itemize}
				\item Linux only uses paging, all segments span full 4GB of virtual memory

				\item Translation done in hardware (by CPU)
				\item Hardware needs to know how to do it:
				\begin{itemize}
					\item Global Descriptor Table (GDT)
					\item Local Descriptor Table (LDT)
					\item Page Directory (PD), Page Tables (PT)
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame} \frametitle{IA-32 virtual (``logical'') address translation}
			\pgfuseimage{ia32-vm} ~~(from [6])
		\end{frame}

		\begin{frame}
			Once we got these structures,
			we know which page belongs where in which address space
			\begin{itemize}
				\item Linux: GDT, LDT are irrelevant (flat segments)
				\item only PD is required
				\item PD references PTs
				\item<2-> PD may have recognisable patterns (has for Linux and Windows)
				\item<2-> one PD per process
			\end{itemize}
		\end{frame}
	
	\subsection{Finding Address Translation Tables}
		
		\begin{frame} \frametitle{Finding ATTs}
			Address Translation Tables (including PDs)\ldots
			\begin{itemize}
				\item depend on \structure{architecture}
				\item depend on \structure{operating system}
				\item may have recognisable patterns
			\end{itemize}
			\uncover<2->{
				$\rightarrow$ create signature for (arch, OS). so far:
				\begin{itemize}
					\item (i386, Linux 2.4 and 2.6)
					\item (i386, Windows XP)
				\end{itemize}
			}
		\end{frame}

		\begin{itemizeframe}{Finding ATTs, details}
			\item[1] Sieve all pages by simple, static pattern (e.g. 4 bytes)
			\item[2] For each possible do statistical analysis:
			\begin{itemize}
				\item Nearest Compression Distance (NCD) to known true ATT
			\end{itemize}
			\item[3] If possibility high enough, test integrity of data \\ (for IA-32: try to load referenced PTs)
			\item[4] If ok, its (most probably) an ATT
		\end{itemizeframe}

		\begin{itemizeframe}{Nearest Compression Distance}
			\item \structure{N}earest \structure{I}nformation \structure{D}istance:
			\begin{itemize}
				\item Minimal amount of changes required between two information
				\item Uses \structure{Kolmogorov Complexity} (KC) (size of minimal representation of information)
				\item Incalculable
			\end{itemize}
			\uncover<2->{
				\item KC can be \structure{approximated} by \structure{compressor} \\
					$\rightarrow$ \structure{N}earest \structure{C}ompression \structure{D}istance:
				\begin{itemize}
					\item Calculable
					\item Very versatile
					\item e.g. create relational trees of gene-sequences [4]
				\end{itemize}
			}
		\end{itemizeframe}

		\begin{frame}
			Once a PD is found, we can do the translation by hand:
			\begin{itemize}
				\item Well-defined algorithm for architecture, e.g. for IA-32: [6]
				\item Implementation in software in \texttt{liblinear}. So far:
				\begin{itemize}
					\item IA-32 Protected Mode, without PAE36 \\ (Linux with $\leq 4$GB RAM)
				\end{itemize}
			\end{itemize}
		\end{frame}

\section{Gathering information}

	\begin{frame}
		So far
		\begin{itemize}
			\item We can \structure{access physical memory sources} in a generic way (\texttt{libphysical})
			\item We can find and \structure{access virtual address spaces} of processes (\texttt{liblinear})
		\end{itemize}
		Now we want to \structure{identify processes} we found.
	\end{frame}

	\subsection{Identifying Processes}
	
		\begin{frame}[fragile]
			\begin{verbatim}
				#include <stdio.h>

				int main(int argc, char**argv)
				{
				    printf("my name is %s\n", argv[0]);
				    return 0;
				}
			\end{verbatim}
			\begin{itemize}
				\item \texttt{argv}, \texttt{envv} are on the stack (first mapped pages below page \texttt{0xc0000})
				\item NUL-separated vector with
				\begin{itemize}
					\item Path of binary
					\item Environment
					\item Arguments
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame}[fragile]
			\scriptsize
			\begin{semiverbatim}
			# OLDPWD=/home/lostrace PWD=/home/lostrace/documents/rwth/SEAT\ \\
			\ \ /attacks/userspace SHLVL=1 _=./victim \ \\
			\ \ ./victim {-}{-}arg=foo bar {-}{-}baz

			0xbfc5ff70  00 00 \textcolor{green}{00 00} 2e 2f 76 69  |..\textcolor{green}{..}./vi|    ARGV[]:
			0xbfc5ff78  63 74 69 6d \textcolor{red}{00} 2d 2d 61  |ctim\textcolor{red}{.}{-}{-}a|      [0] = bfc5ff74
			0xbfc5ff80  72 67 3d 66 6f 6f \textcolor{red}{00} 62  |rg=foo\textcolor{red}{.}b|      [1] = bfc5ff7d
			0xbfc5ff88  61 72 \textcolor{red}{00} 2d 2d 62 61 7a  |ar\textcolor{red}{.}{-}{-}baz|      [2] = bfc5ff87
			0xbfc5ff90  \textcolor{red}{00} 4f 4c 44 50 57 44 3d  |\textcolor{red}{.}OLDPWD=|      [3] = bfc5ff8b
			0xbfc5ff98  2f 68 6f 6d 65 2f 6c 6f  |/home/lo|      [4] = NULL
			0xbfc5ffa0  73 74 72 61 63 65 \textcolor{red}{00} 50  |strace\textcolor{red}{.}P|
			0xbfc5ffa8  57 44 3d 2f 68 6f 6d 65  |WD=/home|
			0xbfc5ffb0  2f 6c 6f 73 74 72 61 63  |/lostrac|
			0xbfc5ffb8  65 2f 64 6f 63 75 6d 65  |e/docume|
			0xbfc5ffc0  6e 74 73 2f 72 77 74 68  |nts/rwth|
			0xbfc5ffc8  2f 53 45 41 54 2f 61 74  |/SEAT/at|
			0xbfc5ffd0  74 61 63 6b 73 2f 75 73  |tacks/us|
			0xbfc5ffd8  65 72 73 70 61 63 65 \textcolor{red}{00}  |erspace\textcolor{red}{.}|
			0xbfc5ffe0  53 48 4c 56 4c 3d 31 \textcolor{red}{00}  |SHLVL=1\textcolor{red}{.}|
			0xbfc5ffe8  5f 3d 2e 2f 76 69 63 74  |_=./vict|
			0xbfc5fff0  69 6d \textcolor{red}{00} 2e 2f 76 69 63  |im\textcolor{red}{.}./vic|
			0xbfc5fff8  74 69 6d \textcolor{green}{00 00 00 00 00}  |tim\textcolor{green}{.....}|
			\end{semiverbatim}
		\end{frame}

		\begin{itemizeframe}{Finding Specific Processes}
			\item[1] Find all virtual address spaces
			\item[2] For each: look if binary matches searched binary
			\begin{itemize}
				\item \texttt{/usr/lib/mozilla-firefox/firefox-bin}
				\item \texttt{/usr/bin/gpg}
				\item \texttt{/usr/bin/ssh-agent}
			\end{itemize}
			\item[3] If matches, steal a cookie or\ldots \uncover<2->{a ssh-private key}
		\end{itemizeframe}

	\subsection{Secrets}

		\begin{frame} \frametitle{Stealing SSH private keys}
			\structure{Let's get dangerous!}

			\uncover<2->{
				Steal SSH private key from \texttt{ssh-agent}:

				\begin{itemize}
					\item agent keeps key decrypted, locked in memory
					\item has timeout-function to wipe keys from memory
					\item stalled in \texttt{read()}-syscall on socket
					\item \alert{no timer} to check for timeout (Fixed by now)
					\item checks timer only on query (Fixed by now)
				\end{itemize}
			}
		\end{frame}

		\begin{frame}[fragile]
			\begin{semiverbatim}
				typedef \textcolor{green}{struct identity} \{
				\ \ 	Key *key;
				\ \ 	char *\textcolor{blue}{comment};  
				\ \           \structure{(key filename: ``\$HOME/.ssh/id\_rsa)''}
				\ \ 	u_int death;
				\} Identity;

				\textcolor{green}{struct Key} \{
				\ \ 	int      type;
				\ \ 	int      flags;
				\ \ 	RSA     *rsa;
				\ \ 	DSA     *dsa;
				\};
			\end{semiverbatim}
		\end{frame}

		\begin{frame} \frametitle{finding SSH Private keys [2]}
			\begin{itemize}
				\item[1] Find \texttt{comment}-string in heap
				\item[2] Find PTR to \texttt{comment} (\texttt{struct identity}) in heap
				\item[3] Follow \texttt{key}, \texttt{key->RSA} and \texttt{key->DSA}
				\item[4] Copy relevant (a lot of arbitrary precision integers), test integrity (see [7,8])
				\item[5] Done.
			\end{itemize}
			\scriptsize (yes, there are better methods to find the keys, but this is just a proof of concept)
		\end{frame}

	\subsection{resume}

		\begin{itemizeframe}{Resume}
			\item So far: only \structure{read} memory.
			\item Works with memory dumps
			\item No time to prepare an attack?
			\item $\rightarrow$ Just dump memory and do it later
		\end{itemizeframe}

\section{Injecting code}

%	\begin{itemizeframe}{Attacking by Writing}
%		\item The pen is mightier than the sword.
%		\item No more sword to be feared than the learned pen.
%		\item Even the virtual one.
%	\end{itemizeframe}

	\subsection{Injecting the code}

		\begin{itemizeframe}{Inject where?}
			\item Cannot allocate extra memory
			\item Cannot overflow a buffer (no I/O with process)
			\item Need to overwrite \structure{code}, \structure{data} or \structure{stack}
			\item Data: can not be easily identified; data may be mapped into multiple processes
		\end{itemizeframe}
			
		\begin{itemizeframe}{Inject into code}
			\item Shared objects, binaries: mapped into multiple processes
			\item $\rightarrow$ Affect multiple processes at same time
			\item Needs to be PIC\footnote{Position Independent Code} (mapped at different locations)
			\item Is there room to inject code?
		\end{itemizeframe}

		\begin{itemizeframe}{Inject into stack}
			\item Stack is easy to find
			\item Affect one process at a time (one stack per thread)
			\item Inject into zero-padded pages containing ENV and ARG.
			\item Possibly overwrite these (if little space):
			\begin{itemize}
				\item ENV, ARG are rarely parsed
				\item typically only during init
			\end{itemize}
			\item If overwrites ENV, ARG: possibly visible via
			\begin{itemize}
				\item \texttt{/proc/\$PID/environ}
				\item \texttt{/proc/\$PID/cmdline}
			\end{itemize}
		\end{itemizeframe}

	\subsection{Executing the code}

		\begin{frame}{Executing injected code}
			Use program-flow:
			\begin{itemize}
				\item Typical process calls subroutines
				\item Stackframes on stack, including return-address
			\end{itemize}
			$\rightarrow$ Overwrite return-addresses
		\end{frame}

%		\begin{itemizeframe}{Protection Mechanisms}
%			\item Stackoverflow protection checksums
%			\begin{itemize}
%				\item Can manipulate checksum as well
%			\end{itemize}
%			\item Page-level no-execute enforcements {\small (Intels EXB, AMDs NX)}
%			\begin{itemize}
%				\item Manipulate Page Directory to allow execution of stack
%			\end{itemize}
%		\end{itemizeframe}

	\subsection{Communicating with shellcode}

		\begin{frame} \frametitle{Rootshell?}
			\begin{itemize}
				\item Royal leage of code-injection: \structure{interactive (root-)shell}
			\end{itemize}
			$\rightarrow$ Inject bindshell
			\begin{itemize}
				\item Network connection required
				\item Can be found simply:
				\begin{itemize}
					\item \texttt{lsof -i -n}
					\item Network sniffer
					\item IDS, NIDS
				\end{itemize}
			\end{itemize}
		\end{frame}

		\begin{frame} \frametitle{Rootshell!}
			$\rightarrow$ Inject Shellcode doing IEEE1394-stuff
			\begin{itemize}
				\item Big, complex payload (IEEE1394 handling)
				\item Attack via IEEE1394?
			\end{itemize}
			$\rightarrow$ Inject Syscall-Proxy
			\begin{itemize}
				\item Victim, self need to be same architecture, OS, syscall interface
				\item I attacked IA-32 from PPC\ldots
			\end{itemize}
		\end{frame}

		\begin{frame} \frametitle{DMA-Shell}
			\begin{itemize}
				\item Only thing that is for sure: DMA
			\end{itemize}
			$\rightarrow$ Communication via DMA
		\end{frame}
		
%		\begin{itemizeframe}{Beachhead}
%			\item Communicate via two Ringbuffers
%			\item Special shellcode (``beachhead'') creates pipes,
%			\item Forks and child executes shell
%			\item Parent creates second thread
%			\item Two threads, two ringbuffers, two pipes:
%			\item Ringbuffer $\rightarrow$ Reader-Thread $\rightarrow$ Pipe $\rightarrow$ Shell
%			\item Ringbuffer $\leftarrow$ Writer-Thread $\leftarrow$ Pipe $\leftarrow$ Shell
%		\end{itemizeframe}

		\begin{frame}
			Special ``Beachhead'' Shellcode: \\
			\pgfuseimage{beachhead}
		\end{frame}
		
		\begin{itemizeframe}{}
			\item Payload small (536 Bytes, yet big for shellcode)
			\item Independent of attackers arch, OS
			\item Only DMA required
		\end{itemizeframe}


\section{Prospects, Conclusion}

	\begin{itemizeframe}{Prospects}
		\item Kernelspace Modifications:
		\begin{itemize} 
			\item Shellcode that injects LKM?
			\item \texttt{/dev/kmem} already emulated by \texttt{liblinear}
			\item Live kernel patching?
		\end{itemize}
		\item Bootstrapping custom operating systems
	\end{itemizeframe}

	\begin{itemizeframe}{Conclusion}
		\item DMA attacks are mature
		\item Access to memory $\rightarrow$ security=0
		\item Keep your firewire-ports secured
		\item Some of the tools (\texttt{libphysical}, \texttt{liblinear}) can also be used for forensics
	\end{itemizeframe}

\AtBeginSection{ }

\section*{}

	\begin{frame}
		\begin{center}
			\Large
			Questions? \\[1.5ex]
			
			Thank you for your attention! \\[1.5ex]
			
			\small
			All tools have been released at \\
			\textcolor{blue}{http://david.piegdon.de/products.html}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Thanks\ldots}
		\begin{itemize}
			\item Maximillian Dornseif, Christian N. Klein and Michael Becher (basic idea)
			\item Timo Boettcher and Alexander Neumann (help)
			\item Swantje Staar (help with english)
			\item Chaos Computer Club Cologne (in general)
		\end{itemize}
		Thank you!
	\end{frame}

	\begin{itemizeframe}{References (FireWire, DMA Attacks)}
		\item[1] \emph{Michael Becher, Maximillian Dornseif, and Christian N.
			Klein.} \structure{Firewire - all your memory are belong to us}. 2005.

		\item[2] \emph{Adam Boileau.} Hit by a bus: Physical access attacks with
			firewire. Ruxcon 2006.

		\item[3] \emph{Mariusz Burdach.} Finding digital evidence in physical memory. 2006.
	\end{itemizeframe}

	\begin{itemizeframe}{References}
		\item[4] \emph{Rudi Cilibrasi and Paul M. B. Vit\'anyi.} Clustering by compression.
			IEEE transactions on information theory, vol. 51, 2005.

		\item[5] \emph{Otto Spaniol et al.} Systemprogrammierung, Skript zur Vorlesung an der RWTH
			Aachen. Wissenschaftsverlag Mainz; Aachener Beitraege zur Informatik (ABI),
			2002. ISBN 3-86073-470-9.
			
		\item[6] \emph{Intel Corp.} Intel 64 and IA-32 Architectures Software Developer’s Manual.
	\end{itemizeframe}

	\begin{itemizeframe}{References}
		\item[7] \emph{Bruce Schneier.} Applied Cryptography (Second Edition). John Wiley \& Sons,
			Inc, 1996. ISBN 0-471-11709-9.
		\item[8] \emph{John Viega and Matt Messier and Pravir Chandra.} Network Security with
			OpenSSL. O'Reilly, 2002. ISBN 0-596-00270-X.
		\item[9] \emph{Joana Rutkowska.} Beyond The CPU: Defeating Hardware Based RAM Acquisition Tools (Part I: AMD case)
	\end{itemizeframe}

\end{document}

