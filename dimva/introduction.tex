% vim: tw=80 ai fdl=99 fo+=a
%
% $Id: introduction.tex 349 2007-02-04 15:43:37Z lostrace $
%

\section{Introduction}

Any modern operating system never grants processes and users access to
physically addressed memory, as this addressing mode circumvents any protection
methods provided by virtual addressing to separate processes from each other and
the operating system. Only the operating system may use physical addressing to
prepare address spaces for each running process, manage these, access special
memory of extension cards and alike, or even only during bootstrapping as Linux
does. Having access to a computer's memory is equal to have the same rights and
possibilities as the computer's operating system. Thus access to it should
require system administrator rights or physical access to the hardware of the
underlying system.  Therefore it is crucial for a system's security to prevent
attackers from gaining direct access to a computer's memory.

Up to recently, protecting access to a computer's memory was equal to prohibit
physical attacks to the hardware, given that the operating system had no
vulnerabilities. Thus, reading and writing to a computer's memory was only
possible by booting custom operating system, opening the case and attacking the
hardware directly, stealing the whole system, installing specially crafted
PCMCIA cards, or the like.  

However, IEEE1394, also known as ``firewire'' and so called in the rest of the
paper, does not require to boot a custom operating system, to open the case,
steal parts of the hardware, install any hardware (except plugging in the
firewire device) or specially crafted hardware.  Access via firewire is as easy
as plugging in a firewire device, like the iPod, letting it do its job and
unplugging it.

In this paper we will introduce several advances in hacking via firewire.  will
As a foundation for the attacks, we introduce two libraries that are used as a
step stone for further work. These libraries are user to access virtual address
spaces of any process on the victim's host. They also provide have a simple,
generic interface for all kinds of physical memory sources. As an example, we
implemented backends for IEEE1394 and filedescriptors so far, but other sources
can be trivially added.

Once, access to the physical memory of a system is obtained, there are two
obvious ways to extract useful information from it: 
\begin{itemize}

	\item It is possible to parse the operating systems internal data
	structures holding all relevant information about loaded drivers,
	running processes et al.
	
	\item It is possible to use the information that the operating system
	provides to the hardware to tell it about the virtual address spaces of
	each process.
	
\end{itemize}

The first scenario will not work between different operating systems and
architectures, since it is necessary to write a parser for each combination of
them, possibly even for different versions of the same operating system. 

The latter uses an information structure that only changes between different
architectures, as the architecture relies on it. Furthermore there is a well
defined algorithm for using this information (implemented in hardware in the
architecture, but well defined in the reference manuals for this architecture,
so system designers can provide valid data to the hardware). On the other hand,
the second approach does not give as much information about the system as the
first, since we obtained there all information directly from the kernel
structures, while using the second approach we only can enter virtual address
spaces of processes. In the following we will use the second approach for most
attacks, as it is more robust.

In \cite{finding_digital_evidence_in_physical_memory:2006}, an approach is
introduced that parses kernel-structures of Windows and Linux kernels. Since the
paper is about \emph{finding an attacker} and not \emph{attacking a system}, the
forensic personal does know about the architecture, the operating system and
version and can build a copy of the system to test its tools, while an attacker
is usually left with guessing the architecture and operating system and needs
more robust tools for his attacks.%  (Obviously this is only a short-term
%argument, as an attacker can also write such tools for \emph{all} OS version
%and architecture combinations\ldots but the heck with this...).  FIXME ``the
%heck with this''... spida: ``for simplicities sake, I will do this for only one
%one combination here, as this is intended to be only a proof of concept''

\subsection{Roadmap}

\textbf{Section \ref{relatedworks}} lists some of the related works in this
area, and how they are related to this piece of research.

In \textbf{section \ref{memsources}}, we will introduce \texttt{libphysical}, a
library providing an attacker with a simple, generic interface to interact with
physical memory via a simple interface.

In \textbf{section \ref{addresstranslations}}, \texttt{liblinear}, an interface
to access virtual address spaces, will be introduced. It incorporates a backend
for IA-32\footnote{This backend is missing algorithms for less-used
operation-modes of the IA-32 architecture, but it will work at least for most
kinds of the \emph{Linux} kernels ($\leq$ 4GB RAM). It has not yet been tested
with \emph{Windows} or \emph{MacOS X} and is missing features (Virtual-8086
mode) to work with DOS-processes running inside Windows.} and functions to find
virtual address spaces.



In \textbf{section \ref{attacks}}, several attacks will be introduces, ranging
from simple information gathering up to obtaining an interactive shell.


In \textbf{section \ref{prospects}}, prospects will be given, what further kinds
of attacks seem to be possible and/or may be of interest.

