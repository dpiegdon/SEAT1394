% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Address translations; virtual, logical, linear and physical addressing}
\label{address_translation}

All multitasking environments that fulfill current requirements have to provide
virtual address spaces for each running process or thread. For performance and
security reason, this address translation from a process's virtual address to an
address valid in physical memory, this is normally performed in hardware.  These
mechanisms can include e.g. segmentation and paging.

A normal process's memory is divisible into several blocks or \emph{segments}:
the \emph{code segment} contains all the code that may be run; the \emph{data
segment} contains the static data that is known at compile time, global
structures or deliberately allocated memory; the \emph{stack segment} contains
the stack, including local variables.  On some architectures, it is possible to
assign segment descriptors, reffering to defined memory regions, to segment
registers.  This assignment will influence the further behaviour of address
translation: all addresses will from there on be taken to be relative to the
bound of the memory region specified by the segment descriptor.

\emph{Paging} will divide the virtual address space of a process into several
consecutive \emph{frames} of a specified page-size (typically 4096 bytes).
Virtual addresses can be split into a frame number and a frame offset; the frame
number is translated (mapped) via a translation table into a physical page
number and the frame offset is used as an offset into this physical page. If a
frame does not have a corresponding physical page, is is called to be unmapped.
Unmapped pages can be non-existing pages or can e.g, be swapped to slower media
like harddisks.

For a detailed description and discussion of these two important mechanisms, the
reader may reffer to a course on system programming, e.g.
\cite{rwth_syspro_scriptum:2002}.

On the IA32 architecture, the CPU can run in various modes of operation; for
secure multitasking operating systems, the \emph{protected mode} is the
preferred one.  The protected mode can use a two-level address translation:
first it will translate the \emph {logical address}, consisting of a segment
selector (which is an index into either the local or the global segment
descriptor table) and an offset to the \emph{linear address}.  The linear
address is then translated via paging to the \emph{physical address}. (The
paging translation is optional and needs to be enabled by setting a special flag
in a control register of the CPU.)

A linux process runs in a simple 4GiB flat virtual address space; no
segmentation is required. Thus, linux will create, among others, that are not of
interest for us, four special segments during boot-up: for each privilige level
(i.e. kernelspace and userspace), it will create segments for both code and
data. These four so called \emph{flat} segments will span the full virtual
address space of 4GiB, thus effectively elliminating segmentation. The address
of the \emph{global descriptor table}, holding the description of these
segments, is then loaded into the \emph{global descriptor table register} (GDTR)
and the specific segment registers are loaded with segment selectors refering to
the segments\footnote{This initialization is done in
\texttt{linux/arch/i386/kernel/head.S}, GDTs are defined at symbols
\texttt{boot\_gdt\_table} and \texttt{cpu\_gdt\_table}}.

The IA32 architecture divides the 4GiB virtual address space into 1024
4MiB-frames. This splitting is defined by the \emph{pagedirectory}. Each entry
of a pagedirectory is 4 Bytes long, thus the pagedirectory is $4*1024 = 4096$
Bytes long. Each of these \emph{pagedirectory entries} (PDEs), if present (its
\texttt{PRESENT}-flag is set), can either refer to a 4MiB physical page or a
pagetable dividing this virtual 4MiB frame further into 4KiB frames. A
\emph{pagetable} is consisting of 1024 4-byte \emph{pagetable entries} (PTEs),
each corresponding to a 4KiB frame.

...

REQ: PDE vs. PAE ; no HIGHMEM-64G (?)

\subsection{Finding address translation tables}
\label{findingATT}

\subsubsection{OS and architecture dependencies; typical address space layout}

\subsubsection{Matching via statisticts: NCD (nearest compression distance)}



\subsection{Example implementation: ia32 backend for \texttt{liblinear}}



