% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Address translations; virtual, logical, linear and physical addressing}
\label{address_translation}

All multitasking environments that fulfill current requirements have to provide
virtual address spaces for each running process or thread. For performance and
security reason, this address translation from a process's virtual address to an
address valid in physical memory, this is normally performed in hardware.  These
mechanisms can include e.g. segmentation and paging.

A normal process's memory is divisible into several blocks or \emph{segments}:
the \emph{code segment} contains all the code that may be run; the \emph{data
segment} contains the static data that is known at compile time, global
structures or deliberately allocated memory (including the heap); the
\emph{stack segment} contains the stack, including local variables.  On some
architectures, it is possible to assign segment descriptors, reffering to
defined memory regions, to segment registers.  This assignment will influence
the further behaviour of address translation: all addresses will from there on
be taken to be relative to the bound of the memory region specified by the
segment descriptor.

\emph{Paging} will divide the virtual address space of a process into several
consecutive \emph{frames} of a specific page-size (typically 4096 bytes).
Virtual addresses can be split into a frame number and a frame offset; the frame
number is translated (mapped) via a translation table into a physical page
number and the frame offset is used as an offset into this physical page. If a
frame does not have a corresponding physical page, is is called to be unmapped.
Unmapped pages can be non-existing pages or can e.g, be swapped to slower media
like harddisks.

For a detailed description and discussion of these two important mechanisms, the
reader may reffer to a course on system programming, e.g.
\cite{rwth_syspro_scriptum:2002}.

\texttt{liblinear} provides a software solution for address translation. The
provided interface is similar to \texttt{libphysical}; it needs a physical
memory source (in form of a \texttt{physical\_handle}), and information about
the target architecture. It provides some functions to find address translation
tables in the raw memory and functions to use them to access the induced virtual
address space.



\subsection{Example implementation: IA32 backend for \texttt{liblinear}}

On the IA32 architecture, the CPU can run in various modes of operation; for
secure multitasking operating systems, the \emph{protected mode} is the
preferred one.  The protected mode can use a two-level address translation:
first it will translate the \emph {logical address}, consisting of a segment
selector (which is an index into either the local or the global segment
descriptor table) and an offset to the \emph{linear address}.  The linear
address is then translated via paging to the \emph{physical address}. (The
paging translation is optional and needs to be enabled by setting a special flag
in a control register of the CPU.)

\label{linux_gdt} A linux process runs in a simple 4GiB flat virtual address
space; no segmentation is required. Thus, linux will create (among others, that
are not of interest for us) four special segments during boot-up: for each
privilige level (i.e. kernelspace and userspace), it will create segments for
both code and data. These four so called \emph{flat} segments will span the full
virtual address space of 4GiB, thus effectively elliminating segmentation. The
address of the \emph{global descriptor table}, holding the description of these
segments, is then loaded into the \emph{global descriptor table register} (GDTR)
and the specific segment registers are loaded with segment selectors refering to
the segments\footnote{This initialization is done in
\texttt{linux/arch/i386/kernel/head.S}, GDTs are defined at symbols
\texttt{boot\_gdt\_table} and \texttt{cpu\_gdt\_table}}.

The IA32 architecture divides the 4GiB virtual address space into 1024
4MiB-frames. This splitting is defined by the \emph{pagedirectory}. Each entry
of a pagedirectory is 4 bytes long, thus the pagedirectory is $4*1024 = 4096$
Bytes long. Each of these \emph{pagedirectory entries} (PDEs), if present (its
\texttt{PRESENT}-flag is set), can either refer to a 4MiB physical page or a
pagetable dividing this virtual 4MiB frame further into 4KiB frames. A
\emph{pagetable} is, again, consisting of 1024 4-byte \emph{pagetable entries}
(PTEs), each corresponding to a 4KiB frame.

REQ: PDE vs. PAE ; no HIGHMEM-64G (?)



\subsection{Finding address translation tables}
\label{findingATT}

When accessing a range of memory via physical addressing, it is neccessary to
find address translation tables to make sence out of the vast, unsorted number
of pages. Typically, translation tables are not marked as such and as we can not
access the processor or the operating system to ask, where these are, we have to
search them. The following methods have proven themselves.



\subsubsection{OS and architecture dependencies; typical address space layout}

Obviously, address translation tables are architecture and operating system
specific; but within an architecture and an operating system, they will often
shared data or specific patterns that are identifiable. For instance, when
searching for linux IA32 address translation tables, one can omit searching the
segment descriptor tables (see section \ref{linux_gdt}) and concentrate on
finding pagedirectories. There are several special patterns that can be found in
a typical pagedirectory of a linux process running on IA32. Following is a
layout of the typical virtual address space of a userspace process:

\begin{itemize}

	\item \emph{code and heap} will be starting somewhere around
	\texttt{0x0800~0000}, consecutively following with a minor number of
	unmapped pages in between

	\item \emph{libraries} will be mapped at \texttt{FIXME!}

	\item the \emph{stack} will be mapped somewhere below
	\texttt{0xc000~0000}, possibly directly starting from
	\texttt{0xbfff~ffff}

	\item starting from \texttt{0xc000~0000}, the approximately lower
	physical 970 MiB of physical RAM will be mapped (only accessible when
	the accessing task is running in ring 0)

	\item the kernelspace stack and other kernel data structures are mapped
	approximately at \texttt{0xfa00~0000 (FIXME!)}

	\item all unmapped pages will have 4-byte entries consisting of zeroes
	(\texttt{0x00~00~00~00})

\end{itemize}

Stack- and memory randomization techniques like \emph{PaX} randomize the base
addresses of these locations a bit, but the general layout stays the same.

Besides searching pages that show non-zero values around these positions and
zero values elsewhere, it is much easier and faster to just check, if the
virtual address \texttt{0xc000~0000} maps to the physical address \texttt{0x0},
because typically the PDE for 4MiB-page no.\@ \texttt{0xc00} will point to the
4MiB physical page at \texttt{0x0}. This test only requires reading the 4byte
PDE entry \texttt{0xc00} and does sort out a vast majority of non-pagedirectory
pages.



\subsubsection{Matching via statisticts: NCD (normalized compression distance)}

FIXME

The \emph{normalized information distance} (NID), a form of similarity distance
measurement, can be understood as a measurement for the minimal amount of
changes required to change one information into another one.  A NID of 1 means,
that two informations are totally unrelated; a NID of 0 means, that they are the
same.  Due to its relation to the \emph{Kolmogorov complexity} (a measurement
for an informations shortest description in a fixed description language), it is
incalculateable.  As an approximation, it is possible to use data compressors
instead of the Kolmogorov complexity to measure the size of a minimal
representation of an information. The resulting \emph{normalized compression
distance} has proven to be useful in a vast area of applications; for instance,
it has shown its usefulness during analysis of DNA sequences or languages for
relatedness (\cite{clustering_by_compression:2005},
\cite{similarity_matrix:2004}), MIDI music files for relations in style and
creator (\cite{clustering_by_compression:2005}) and attack schemes of virii and
worms (\cite{analysing_worms_with_ncd:2006}).  For a detailed introduction and
analysis of the NCD and sample applications, the reader may refer to the above
texts.

\texttt{liblinear} uses the NCD to measure the distance between a known true
pagedirectory against a page of unknown data to determine, whether this page
could be a pagedirectory. The \texttt{complearn}-toolkit
\cite{complearn_homepage} provides a suite of functions for generating distance
matrixes between informations, generating relational trees from these and more.
As we only need to compare two pages, this set of functions is far too big and
the interface far too complex for this application. Thus, I implemented my own,
very short NCD version (\texttt{simple\_ncd()} in
\texttt{liblinear/simple\_ncd.c}, using BZip2 as compressor.

FIXME

