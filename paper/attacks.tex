% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Attacking}




\subsection{Information Gathering}

\subsubsection{Identifying processes}

Once an address translation table has been found, it is of interest, what kind
of process resides in this virtual address space.  For userspace applications on
IA32-Linux there is a simple way to identify a process's \emph{filename}, its
\emph{arguments} and even its full set of \emph{environment variables}: This
information is often required by a process and thus the kernel will provide it
to the process by copying it to the bottom pages of the application's
stack\footnote{i.e.  the stack-pages that are found first when seeking downward
from virtual address \texttt{0xbfff~f000}}.

\texttt{proc\_info()} will seek the stack-bottom, parse it and return
ready-for-use environment vectors, command-line vectors and the full path of the
binary for a given linear address space. \texttt{remote-ps}, located in
\texttt{attacks/information/}, uses \texttt{proc\_info()} for each found address
space and will print a list of all found processes with its arguments.


\subsubsection{Typical places to find secrets}

Many applications keep secrets in their memory, some of them even locking them
into the main memory\footnote{e.g. via the \emph{mlock} function} to prevent the
operating system from swapping them to slower (permanent) media.  ``Secrets''
includes, among other information, \emph{authentication data},
\emph{cryptographic key material}, \emph{random data} (e.g. to seed a
cryptographic algorithm) and sometimes even \emph{algorithms} (\emph{proprietary
software}). Authentication data can be e.g.  passwords or private keys for
signature algorithms; cryptographic key material, as the name says, are keys for
usage with cryptographic algorithms (like the above signature algorithms). These
two will be of main interest in this section.

Many applications using a cryptographic infrastructure for communications will
keep once loaded passwords or keys in their main memory for successive usage.
The operating systems protection model ensures the safety of this information
from other processes running on the same system; but by accessing the main
memory we do have full access to this material. The only task that remains is to
reconstruct the key material and passwords from the memory.

As an example, the following applications are of interest:

\begin{itemize}

	\item GnuPG and PGP: applications to sign and encrypt arbitrary data
	with public/private keypairs. They are wide spread for email-encryption
	and -signing.

	\item sshd, ssh and ssh-agent: the \emph{secure shell} application is an
	extended, encrypted version of telnet using strong cryptography,
	including passwords, skey, x509 certificates, RSA and DSA keys.

	\item Apache and other SSL-enabled web servers.

	\item OpenVPN, Cisco-VPN and other VPN-servers and clients

	\item Instant Messaging Applications, e.g. Psi keeps the authentication
	information and possibly the GnuPG keypair in memory.

	\item The computer BIOS password, ATA password or PGP-Wholedisk
		password: the computer or its drives can be locked with a BIOS
		password or the harddisk can be encrypted.  For a sample attack,
		see \cite{rux2k6firewire:2006}.

\end{itemize}


\subsubsection{Example attack: ssh-agent snarfer}

% FIXME: def. "snarfing"? well... is defined in wiktionary but marked with a
% "request for verification"
\label{ssh-agent-snarfer} To proof that it is rather easy to obtain secret keys
from a process I have written a sample attack to obtain
%
(snarf\footnote{to snarf: To grab, esp. to grab a large document or file for the
purpose of using it with or without the author's permission. // To acquire, with
little concern for legal forms or politesse (but not quite by stealing).
(source: \href{http://catb.org/jargon/html/S/snarf.html}{Jargon Files})})
%
\emph{ssh public/private keypairs} from \texttt{ssh-agent}s via \emph{firewire}.

When using \texttt{ssh} for accessing remote computers it is possible to
authenticate via passwords, public/private keypairs and various other methods.
The usage of public/private keypairs is wide-spread among people using
\texttt{ssh} on a regular basis. These keypairs can either be a DSA or a RSA
keypair, they are typically created with \texttt{ssh-keygen} and stored
somewhere in \texttt{\$HOME/.ssh/}, e.g.  \texttt{/root/.ssh/id\_dsa} and
\texttt{/root/.ssh/id\_dsa.pub}. Keypairs can and should be encrypted with a
passphrase to prevent attackers from using them, if they were able to obtain
them somehow. Thus to use a keypair it is required to enter this passphrase each
time. This can be disturbing during frequent usage, e.g. when using
\texttt{ssh+svn} or \texttt{scp} with remote-tab-completion (\texttt{zsh} is
capable of this).

For these and other reasons, the \texttt{ssh-agent} has been developed. This
agent will run in the background; the user can store a keypair into it (once
entering the passphrase to unlock the keypair) and successively use the keypair
without the requirement to enter the passphrase each time. The keypair can be
wiped from memory on demand and also be loaded only for a specified period of
time.

Actually, here begins the fun. During my tests I found that the key is
\emph{not} wiped from memory when the time limit is hit. It will be wiped the
next time the ssh-agent is queried (via its socket), but the agent is stalled in
a \emph{read} system call until this query and thus can not wipe the key. That
makes it possible to obtain long overdue keys from \texttt{ssh-agent}s, although
their owners believed them to be safe. A simple timer could have prevented this
-- I hereby strongly encourage the developers to implement such a timer. But
even with such a timer enabled it would be possible to acquire the key during
its lifetime.

To obtain a keypair from an agent via firewire, a staged attack is required:

%\lstset{numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt}
\lstset{language=C, numbers=left, numberstyle=\tiny, frame=lines}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		typedef struct identity {
			TAILQ_ENTRY(identity) next;
			Key *key;
			char *comment;
			u_int death;
			u_int confirm;
		} Identity;

		typedef struct {
			int nentries;
			TAILQ_HEAD(idqueue, identity) idlist;
		} Idtab;

		/* private key table, one per protocol version */
		Idtab idtable[3];
	\end{lstlisting}
	\caption{\texttt{openssh/ssh-agent.c}: Identity structure and \texttt{idtable}}
	\label{fig:code:identity-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		enum types {
			KEY_RSA1,
			KEY_RSA,
			KEY_DSA,
			KEY_UNSPEC
		};

		struct Key {
			int      type;
			int      flags;
			RSA     *rsa;
			DSA     *dsa;
		};
	\end{lstlisting}
	\caption{\texttt{openssh/key.h}: Key-structure}
	\label{fig:code:key-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Declared already in ossl_typ.h */
		/* typedef struct rsa_st RSA; */
		struct rsa_st {
			int pad;
			long version;
			const RSA_METHOD *meth;
			ENGINE *engine;
			BIGNUM *n;
			BIGNUM *e;
			BIGNUM *d;
			BIGNUM *p;
			BIGNUM *q;
			BIGNUM *dmp1;
			BIGNUM *dmq1;
			BIGNUM *iqmp;
			int flags;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/rsa/rsa.h}: RSA structure (stripped down)}
	\label{fig:code:rsa-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Already defined in ossl_typ.h */
		/* typedef struct dsa_st DSA; */
		struct dsa_st {
			int pad;
			long version;
			int write_params;
			BIGNUM *p;
			BIGNUM *q;      /* == 20 */
			BIGNUM *g;
			BIGNUM *pub_key;  /* y public key */
			BIGNUM *priv_key; /* x private key */
			int flags;
			const DSA_METHOD *meth;
			ENGINE *engine;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/dsa/dsa.h}: DSA structure (stripped down)}
	\label{fig:code:dsa-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Already declared in ossl_typ.h */
		/* typedef struct bignum_st BIGNUM; */
		struct bignum_st {
			BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
			int top;        /* Index of last used d +1. */
			/* The next are internal book keeping for bn_expand. */
			int dmax;       /* Size of the d array. */
			int neg;        /* one if the number is negative */
			int flags;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/bn/bn.h}: BIGNUM structure (stripped down)}
	\label{fig:code:bignum-struct}
\end{center}\end{figure}


\begin{enumerate}

	\item Seek the first GiB of physical memory for pagetables.

	\item For each pagetable: check with the introduced
	\texttt{proc\_info()}, if the found userspace belongs to a
	\texttt{ssh-agent} process. If not, seek next pagetable.

	\item Use the obtained environment to resolve the users home directory
	(\texttt{\$HOME}) and construct a path where keypairs most likely reside
	in the file system (e.g.  ``\texttt{\$HOME/.ssh/}'') and seek this
	string in the heap.  This approach will only find keypairs that have
	been loaded with this key-location.\footnote{Actually this field is the
	key's comment-field that is mostly unused and overwritten with the
	filename of the key. Keypairs that are used with SSH protocol version 2
	(virtually all) do not have a comment-field; during loading, the
	comment-field is always initialized with the keys pathname.} Keypairs
	loaded from different locations or via a relative path can thus not be
	found by this search.
	
	\item All loaded keypairs have a corresponding \emph{identity-struct} in
		an agent (see figure \ref{fig:code:identity-struct}). Among
		other fields, this identity-struct contains a link to a key
		struct, the above mentioned path/comment-field and the lifetime
		of the key. Thus to find the identity struct corresponding to a
		found comment-field, one has to search the address of the
		comment-field in the heap of the agent.
	
	\item Once the \emph{key-struct} (figure \ref{fig:code:key-struct}),
		that is linked to by the identity-struct, has been found, one
		can determine whether the found key is a RSA or a DSA key.  The
		key-struct contains a type-field and two pointers to either the
		RSA or the DSA key.  These referenced structures are the
		\emph{OpenSSL}\footnote{OpenSSL
		(\href{http://openssl.org}{http://openssl.org}) is a free
		open-source implementation of the secure socket layer protocol
		also providing a general purpose cryptography library
		(\text{libcrypto}).}-structures \texttt{RSA} and \texttt{DSA}.
	
	\item For both RSA and DSA structures (figure \ref{fig:code:rsa-struct}
		and \ref{fig:code:dsa-struct}), all important fields need to be
		recovered to obtain valid keypairs.  \cite{applied_crypto:1996,
		handbook_applied_crypto:2001} give an overview of both
		cryptographic algorithms, \cite{openssl_book:2002} introduces
		openssl concepts and implementation details. Openssl's arbitrary
		precision integer implementation is the \texttt{BIGNUM}-struct
		(often abbreviated ``BN'').  It consists of a variable-length
		array of bit-vectors forming the value and a length-field
		defining the length of this array (see figure
		\ref{fig:code:bignum-struct}).  As RSA and DSA both operate on
		finite fields, both are implemented with \texttt{BIGNUM}s.
		Therefore, the RSA and DSA structures contain several
		\texttt{BIGNUM}s that need to be recovered to obtain a valid
		copy of the keypair.

	\item Some validity tests may be done to verify that the acquired
	\texttt{BIGNUM}s fulfill algorithm-specific properties\footnote{During
	development it was useful to test obtained keys for some properties that
	are required. These tests are implemented in
	\texttt{attacks/information/sshkey-sanitychecks.c}} and thus form a
	valid keypair.

	\item Attach the obtained \texttt{BIGNUM}s back into valid RSA or DSA
	structures and save these keys to a file using openssl-functions.
	
\end{enumerate}
	
The search algorithm (2,3,4) is far from perfect but works rather well.  To
create a better algorithm remains as an exercise to the interested reader. For
instance, a much better algorithm to find the \emph{identity}-structs is to use
the ELF-headers of the mapped executable to resolve the symbol of the
\emph{idtable}\footnote{The \emph{idtable} is a structure referencing all keys
that are loaded into the agent.}. This approach is straight-forward, hits
\emph{all} keys and would have worked almost always, if not many (almost all)
distributions distributed programs with their symbols stripped (due to size and
security reasons); this invalidates the symbol-resolution-approach, as this
stripping also removes any information of the \emph{idtable} symbol.

Furthermore once \emph{one} \emph{identity}-struct is found, \emph{all} structs
of the same key-type (RSA or DSA) could be found by walking the list this key is
linked into.

As stated above, the keypairs reside decrypted in the memory of the agent (even
if overtime) and thus, when snarfed and stored to a file, can be immediately
used by the command \texttt{ssh~-i~keyfile~user@host}~.  Such an attack will not
take much longer than searching the first 1 GiB of physical RAM for
pagedirectories, that is \emph{typically no more than 15 seconds}. If an attack
fails but an agent was found, it would be possible to just dump the heap of the
agent and stage a more thorough attack at a later time. Once the heap is dumped,
all required data is obtained. A similar attack via \emph{ptrace} should be
possible as well.

The reader may refer to \texttt{attacks/information/snarf-sshkey.c} in the
corresponding tarball for the source-code of the attack. Please keep in mind
that this attack will only find keys loaded with the absolute path
\texttt{\$HOME/.ssh/}.


\subsubsection{Matching and statistics to find secret keys}

\cite{hide_n_seek:1998} introduces some schemes to find secret keys in random
data and some countermeasures. It takes a special look at finding private RSA
keys if their corresponding public keys are known and finding keys by searching
high-entropy regions. Though I encourage the reader to read this interesting
paper, the circumstances are most likely very different now: cheap and small
storage media like flash-memory and small harddisks have increased portable
storage to a huge size, equal or larger than the memory a computer system
typically has. Thus, an attacker can just dump the full memory or a subset of it
(like the virtual address space of a single process) that is promising to
contain a secret. A thorough attack can then be staged later.  Still, searching
private keys with the introduced methods can be very helpful, if reconstruction
of the used data-structures is impossible or more expensive. Furthermore, when
trying to obtain a private key, often enough the corresponding public key is
unknown. This invalidates the approaches introduced to find RSA secret keys that
require the public key.




\subsection{Userspace Modifications}

It is important to know a few details about executables, libraries and processes
to understand this section.

Each executable object, including libraries and executables, can be separated
into code and data, where the code should be read-only during execution. The
data can further be separated into read-only data, read-write data and
uninitialized global variables (local variables will be allocated from the
stack, runtime-allocated memory is allocated from the heap).  Thus an executable
object may be split into four regions: \emph{code}, \emph{rodata} (constants),
\emph{rwdata} and \emph{dynamic data} (rwdata may also be implemented by copying
the initial data from rodata to dynamic data); stack and heap are
process-specific.

As many different processes may use the same executable objects, it would be a
waste of memory if the operating system created a copy of the object for each
reference to it.

Code and rodata may not be written to by a process, thus the operating system
can share these two regions among processes that are using the same objects
(binaries or libraries).  Thus, once an operating system \emph{ensures} that a
process can not write to code-regions and read-only data-regions, it can map
these once loaded regions into multiple virtual address spaces. This enforcement
is done in hardware, on IA32 by setting a flag in the page directory or a page
table referencing the specific physical memory pages containing the region.

Newer CPUs provide \emph{page-level no-execute enforcements} (AMD's NX \emph{No
eXecute bit}, Intel's EXB \emph{EXecute disable Bit}); equal segment-level
enforcements exist for years but never have been used in mainstream as Linux and
many other operating-systems use a flat memory-model (with only one big segment
spanning the full virtual address space).  Once these page-level enforcements
are used in systems, attacks that inject code into data-regions or the stack are
rendered completely useless. However with access to the data-structures (page
directory and page tables) containing the information, which pages are
executable and which not, one can change this information before injecting code
e.g. into an applications stack. 

On Linux, programs and libraries are in \emph{Executable and Linker Format}
(ELF).  This format is roughly described in the manpage \texttt{elf(5)}. When a
binary is mapped into a process's memory, it is mapped including the full ELF
header containing all information that is required to link all references
between different objects; ELFs are always mapped at page-bounds. Due to this,
all mapped ELFs (that includes executables and libraries) can be found by
scanning all pages for the ELF Magic (0x7f E L F) at offset $0$ in the page.
Libraries, executables and other ELF objects can be distinguished by evaluating
the \texttt{e\_type} field of the ELF header.

\subsubsection{Overwriting executable or library code}

When code of executables or libraries are changed, all programs using these ELF
objects are influenced at the same time. An attacker thus has the ability, but
also the burden, to possibly infect several processes at the same time. Such an
attack has to be carefully prepared and conducted, as each system may have a
different version of a binary and overwriting the wrong parts of an ELF or
writing the wrong code may result in an almost immediate crash of all processes
using the ELF. Though this is a rather interesting approach, there are easier
ways to inject code into a \emph{single} process (see \ref{overwriting_stack}).

For example, such an attack could be conducted by parsing a single virtual
address space, until the glibc is found and then parsing the ELF-headers and
searching for the entry-point of the \texttt{printf}-function (or some other,
less frequently used function). Then a piece of code could be injected into the
unused fragment of the last page of the libc-mapping. The intention is to
overwrite the \texttt{printf} functions code with a \emph{relative}\footnote{An
ELF may be mapped at different locations in different processes, if it is
``PIC'' or ``PIE'' (Position Independant Code/Executable) and the kernel
supports this.  Thus, unless the ELF is only mapped in one process or the
overwritten function is only used in one process, the jumps target has to be
addressed relative to the current position.} jump to this injected code.  But as
we need to overwrite some instructions inside the function, we need to parse the
functions code to separate each instruction\footnote{on IA32, different machine
instructions can have different length}, so that after our code is executed, it
executes a copy of the overwritten instructions and jumps to a fully intact
instruction right after the injected jump. After this has been done, the jump
can be injected into the functions code. This last write has to be as atomic as
possible, as a process may just be executing these bytes and thus get astray.
On IA32, entry-points of functions are most likely aligned to 32-bit
addresses\footnote{due to optimizations by the compiler}.  Firewire also
provides an interface to write 32-bit aligned 32-bit values (``quads'')
atomically.  Unfortunately, a \emph{relative short} jump ($2$ bytes) can only
jump within $\pm256$ bytes from the jump itself and \emph{relative long} and
\emph{absolute} jumps are $5$ bytes wide ($1$ byte command + $4$ bytes address).
A short jump is most likely incapable of reaching the last page of the ELF and
writing a long relative jump is not atomic.

A lot of other methods to inject code into a running process have been
developed; e.g. \cite{phrack59.8:2002} gives an introduction into using
\emph{ptrace}, including injecting whole shared objects using the runtime linker
\emph{libdl}. The usability of this approach has not yet been analysed.


\subsubsection{Overwriting the stack and return addresses}

\label{overwriting_stack} I have put most of my efforts into injecting code into
the stack and overwriting return-addresses on the stack to point to the injected
code.

This modification of the classic \emph{stack overflow} method has some
advantages over the previous approach:

\begin{itemize}

	\item Each process, even each thread, has its own stack. Thus only a
		single thread will be affected by the attack.

	\item If the attack fails and the thread dies, only a \emph{single}
		thread will fail on the target system, not e.g. \emph{all}
		processes using the glibc or \emph{all} instances of $/bin/sh$.

	\item The process can write to the stack as well, thus we can
		communicate with the injected shell-code in a rather easy way.

	\item During the attack we do not need to modify parts of the code of
		the target-process, reducing the risc of an astray process.

\end{itemize}

An attack can be as simple as injecting the code into a location on the stack
that is known to be unused and then changing all doubles on the stack that look
like a return-address into the heap (\texttt{0x08**~****}, see figure
\ref{fig:linux_virtual_address_space}) to point to the injected shell code. Once
the attacked process leaves the current stack-frame, it will use the
return-address on the stack and, as this has been changed by us, execute the
injected shell code.

% FIXME: mehr infos zu ``3.1.1:Identifying processes'', danach hier darauf
% aufbauen. Mehr infos zu stack-frames?



\subsection{Kernelspace Modifications}

\subsubsection{Emulating \texttt{/dev/kmem}}

\subsubsection{Resolving kernel addresses}





\subsection{Bootstrapping custom operating systems}

