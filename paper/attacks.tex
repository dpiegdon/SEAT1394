% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Attacking}




\subsection{Information Gathering}

\subsubsection{Identifying processes}

\label{identifying_processes}  Once an address translation table has been found,
it is of interest, what kind of process resides in this virtual address space.
For userspace applications on IA-32-Linux there is a simple way to identify a
process's \emph{filename}, its \emph{arguments} and even its full set of
\emph{environment variables}: This information is often required by a process
and thus the kernel will provide it to the process by copying it to the bottom
pages of the application's stack\footnote{i.e.  the stack-pages that are found
first when seeking downward from virtual address \texttt{0xbfff~f000}}.

\texttt{proc\_info()} will seek the stack-bottom, parse it and return
ready-for-use environment vectors, command-line vectors and the full path of the
binary for a given linear address space. \texttt{remote-ps}, located in
\texttt{attacks/information/}, uses \texttt{proc\_info()} for each found address
space and will print a list of all found processes with its arguments.

% FIXME ``etwas mehr drueber, was man damit alles boeses machen kann''

\subsubsection{Typical places to find secrets}

Many applications keep secrets in their memory, some of them even locking them
into the main memory\footnote{e.g. via the \emph{mlock} function} to prevent the
operating system from swapping them to slower (permanent) media.  ``Secrets''
includes, among other information, \emph{authentication data},
\emph{cryptographic key material}, \emph{random data} (e.g. to seed a
cryptographic algorithm) and sometimes even \emph{algorithms} (\emph{proprietary
software}). Authentication data can be e.g.  passwords or private keys for
signature algorithms; cryptographic key material, as the name says, are keys for
usage with cryptographic algorithms (like the above signature algorithms). These
two will be of main interest in this section.

Many applications using a cryptographic infrastructure for communications will
keep once loaded passwords or keys in their main memory for successive usage.
The operating systems protection model ensures the safety of this information
from other processes running on the same system; but by accessing the main
memory we do have full access to this material. The only task that remains is to
reconstruct the key material and passwords from the memory.

As an example, the following applications are of interest:

\begin{itemize}

	\item GnuPG and PGP: applications to sign and encrypt arbitrary data
	with public/private keypairs. They are wide spread for email-encryption
	and -signing.

	\item sshd, ssh and ssh-agent: the \emph{secure shell} application is an
	extended, encrypted version of telnet using strong cryptography,
	including passwords, skey, x509 certificates, RSA and DSA keys.

	\item Apache and other SSL-enabled web servers.

	\item OpenVPN, Cisco-VPN and other VPN-servers and clients

	\item Instant Messaging Applications, e.g. Psi keeps the authentication
	information and possibly the GnuPG keypair in memory.

	\item The computer BIOS password, ATA password or PGP-Wholedisk
		password: the computer or its drives can be locked with a BIOS
		password or the harddisk can be encrypted.  For a sample attack,
		see \cite{rux2k6firewire:2006}.

\end{itemize}


\subsubsection{Example attack: ssh-agent snarfer}

\label{ssh-agent-snarfer} To proof that it is rather easy to obtain secret keys
from a process I have written a sample attack to obtain
%
(snarf\footnote{to snarf: To grab, esp. to grab a large document or file for the
purpose of using it with or without the author's permission. // To acquire, with
little concern for legal forms or politesse (but not quite by stealing).
(source: \href{http://catb.org/jargon/html/S/snarf.html}{Jargon Files})})
%
\emph{ssh public/private keypairs} from \texttt{ssh-agent}s via \emph{firewire}.

When using \texttt{ssh} for accessing remote computers it is possible to
authenticate via passwords, public/private keypairs and various other methods.
The usage of public/private keypairs is wide-spread among people using
\texttt{ssh} on a regular basis. These keypairs can either be a DSA or a RSA
keypair, they are typically created with \texttt{ssh-keygen} and stored
somewhere in \texttt{\$HOME/.ssh/}, e.g.  \texttt{/root/.ssh/id\_dsa} and
\texttt{/root/.ssh/id\_dsa.pub}. Keypairs can and should be encrypted with a
passphrase to prevent attackers from using them, if they were able to obtain
them somehow. Thus to use a keypair it is required to enter this passphrase each
time. This can be disturbing during frequent usage, e.g. when using
\texttt{ssh+svn} or \texttt{scp} with remote-tab-completion (\texttt{zsh} is
capable of this).

For these and other reasons, the \texttt{ssh-agent} has been developed. This
agent will run in the background; the user can store a keypair into it (once
entering the passphrase to unlock the keypair) and successively use the keypair
without the requirement to enter the passphrase each time. The keypair can be
wiped from memory on demand and also be loaded only for a specified period of
time.

Actually, here begins the fun. During my tests I found that the key is
\emph{not} wiped from memory when the time limit is hit. It will be wiped the
next time the ssh-agent is queried (via its socket), but the agent is stalled in
a \emph{read} system call until this query and thus can not wipe the key. That
makes it possible to obtain long overdue keys from \texttt{ssh-agent}s, although
their owners believed them to be safe. A simple timer could have prevented this
-- I hereby strongly encourage the developers to implement such a timer. But
even with such a timer enabled it would be possible to acquire the key during
its lifetime.

To obtain a keypair from an agent via firewire, a staged attack is required:

%\lstset{numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt}
\lstset{language=C, numbers=left, numberstyle=\tiny, frame=lines}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		typedef struct identity {
			TAILQ_ENTRY(identity) next;
			Key *key;
			char *comment;
			u_int death;
			u_int confirm;
		} Identity;

		typedef struct {
			int nentries;
			TAILQ_HEAD(idqueue, identity) idlist;
		} Idtab;

		/* private key table, one per protocol version */
		Idtab idtable[3];
	\end{lstlisting}
	\caption{\texttt{openssh/ssh-agent.c}: Identity structure and \texttt{idtable}}
	\label{fig:code:identity-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		enum types {
			KEY_RSA1,
			KEY_RSA,
			KEY_DSA,
			KEY_UNSPEC
		};

		struct Key {
			int      type;
			int      flags;
			RSA     *rsa;
			DSA     *dsa;
		};
	\end{lstlisting}
	\caption{\texttt{openssh/key.h}: Key-structure}
	\label{fig:code:key-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Declared already in ossl_typ.h */
		/* typedef struct rsa_st RSA; */
		struct rsa_st {
			int pad;
			long version;
			const RSA_METHOD *meth;
			ENGINE *engine;
			BIGNUM *n;
			BIGNUM *e;
			BIGNUM *d;
			BIGNUM *p;
			BIGNUM *q;
			BIGNUM *dmp1;
			BIGNUM *dmq1;
			BIGNUM *iqmp;
			int flags;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/rsa/rsa.h}: RSA structure (stripped down)}
	\label{fig:code:rsa-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Already defined in ossl_typ.h */
		/* typedef struct dsa_st DSA; */
		struct dsa_st {
			int pad;
			long version;
			int write_params;
			BIGNUM *p;
			BIGNUM *q;      /* == 20 */
			BIGNUM *g;
			BIGNUM *pub_key;  /* y public key */
			BIGNUM *priv_key; /* x private key */
			int flags;
			const DSA_METHOD *meth;
			ENGINE *engine;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/dsa/dsa.h}: DSA structure (stripped down)}
	\label{fig:code:dsa-struct}
\end{center}\end{figure}

\begin{figure}[ht] \begin{center}
	\tiny
	\begin{lstlisting}
		/* Already declared in ossl_typ.h */
		/* typedef struct bignum_st BIGNUM; */
		struct bignum_st {
			BN_ULONG *d;    /* Pointer to an array of 'BN_BITS2' bit chunks. */
			int top;        /* Index of last used d +1. */
			/* The next are internal book keeping for bn_expand. */
			int dmax;       /* Size of the d array. */
			int neg;        /* one if the number is negative */
			int flags;
		};
	\end{lstlisting}
	\caption{\texttt{openssl/crypto/bn/bn.h}: BIGNUM structure (stripped down)}
	\label{fig:code:bignum-struct}
\end{center}\end{figure}


\begin{enumerate}

	\item Seek the first GiB of physical memory for pagetables.

	\item For each pagetable: check with the introduced
		\texttt{proc\_info()}, if the found userspace belongs to a
		\texttt{ssh-agent} process. If not, seek next pagetable.

	\item Use the obtained environment to resolve the users home directory
		(\texttt{\$HOME}) and create a path where keypairs most likely
		reside in the file system (e.g.  ``\texttt{\$HOME/.ssh/}'') and
		seek this string in the heap.  This approach will only find
		keypairs that have been loaded with this
		key-location.\footnote{Actually this field is the key's
		comment-field that is mostly unused and overwritten with the
		filename of the key. Keypairs that are used with SSH protocol
		version 2 (virtually all) do not have a comment-field; during
		loading, the comment-field is always initialized with the keys
		pathname.} Keypairs loaded from different locations or via a
		relative path can thus not be found by this search.
	
	\item All loaded keypairs have a corresponding \emph{identity-struct} in
		an agent (see figure \ref{fig:code:identity-struct}). Among
		other fields, this identity-struct contains a link to a key
		struct, the above mentioned path/comment-field and the lifetime
		of the key. Thus to find the identity struct corresponding to a
		found comment-field, one has to search the address of the
		comment-field in the heap of the agent.
	
	\item Once the \emph{key-struct} (figure \ref{fig:code:key-struct}),
		that is linked to by the identity-struct, has been found, one
		can determine whether the found key is a RSA or a DSA key.  The
		key-struct contains a type-field and two pointers to either the
		RSA or the DSA key.  These referenced structures are the
		\emph{OpenSSL}\footnote{OpenSSL
		(\href{http://openssl.org}{http://openssl.org}) is a free
		open-source implementation of the secure socket layer protocol
		also providing a general purpose cryptography library
		(\text{libcrypto}).}-structures \texttt{RSA} and \texttt{DSA}.
	
	\item For both RSA and DSA structures (figure \ref{fig:code:rsa-struct}
		and \ref{fig:code:dsa-struct}), all important fields need to be
		recovered to obtain valid keypairs.  \cite{applied_crypto:1996,
		handbook_applied_crypto:2001} give an overview of both
		cryptographic algorithms, \cite{openssl_book:2002} introduces
		OpenSSL concepts and implementation details. OpenSSL`s arbitrary
		precision integer implementation is the \texttt{BIGNUM}-struct
		(often abbreviated ``BN'').  It consists of a variable-length
		array of bit-vectors forming the value and a length-field
		defining the length of this array (see figure
		\ref{fig:code:bignum-struct}).  As RSA and DSA both operate on
		finite fields, both are implemented with \texttt{BIGNUM}s.
		Therefore, the RSA and DSA structures contain several
		\texttt{BIGNUM}s that need to be recovered to obtain a valid
		copy of the keypair.

	\item Some validity tests may be done to verify that the acquired
		\texttt{BIGNUM}s fulfill algorithm-specific
		properties\footnote{During development it was useful to test
		obtained keys for some properties that are required. These tests
		are implemented in
		\texttt{attacks/information/sshkey-sanitychecks.c}} and thus
		form a valid keypair.

	\item Attach the obtained \texttt{BIGNUM}s back into valid RSA or DSA
		structures and save these keys to a file using
		openssl-functions.
	
\end{enumerate}
	
The search algorithm (2,3,4) is far from perfect but works rather well.  To
create a better algorithm remains as an exercise to the interested reader. For
instance, a much better algorithm to find the \emph{identity}-structs is to use
the ELF-headers of the mapped executable to resolve the symbol of the
\emph{idtable}\footnote{The \emph{idtable} is a structure referencing all keys
that are loaded into the agent.}. This approach is straight-forward, hits
\emph{all} keys and would have worked almost always, if not many (almost all)
distributions distributed programs with their symbols stripped (due to size and
security reasons); this invalidates the symbol-resolution-approach, as this
stripping also removes any information of the \emph{idtable} symbol.

Furthermore once \emph{one} \emph{identity}-struct is found, \emph{all} structs
of the same key-type (RSA or DSA) could be found by walking the list this key is
linked into.

As stated above, the keypairs reside decrypted in the memory of the agent (even
if overtime) and thus, when snarfed and stored to a file, can be immediately
used by the command \texttt{ssh~-i~keyfile~user@host}~.  Such an attack will not
take much longer than searching the first 1 GiB of physical RAM for
pagedirectories, that is \emph{typically no more than 15 seconds}. If an attack
fails but an agent was found, it would be possible to just dump the heap of the
agent and stage a more thorough attack at a later time. Once the heap is dumped,
all required data is obtained. A similar attack via \emph{ptrace} should be
possible as well.

The reader may refer to \texttt{attacks/information/snarf-sshkey.c} in the
corresponding tarball for the source-code of the attack. Please keep in mind
that this attack will only find keys loaded with the absolute path
\texttt{\$HOME/.ssh/}.


\subsubsection{Matching and statistics to find secret keys}

\cite{hide_n_seek:1998} introduces some schemes to find secret keys in random
data and some countermeasures. It takes a special look at finding private RSA
keys if their corresponding public keys are known and finding keys by searching
high-entropy regions. Though I encourage the reader to read this interesting
paper, the circumstances are most likely very different now: cheap and small
storage media like flash-memory and small harddisks have increased portable
storage to a huge size, equal or larger than the memory a computer system
typically has. Thus, an attacker can just dump the full memory or a subset of it
(like the virtual address space of a single process) that is promising to
contain a secret. A thorough attack can then be staged later.  Still, searching
private keys with the introduced methods can be very helpful, if reconstruction
of the used data-structures is impossible or more expensive. Furthermore, when
trying to obtain a private key, often enough the corresponding public key is
unknown. This invalidates the approaches introduced to find RSA secret keys that
require the public key.




\subsection{Userspace Modifications}

It is important to know a few details about executables, libraries and processes
to understand this section.

Each executable object, including libraries and executables, can be separated
into code and data, where the code should be read-only during execution. The
data can further be separated into read-only data, read-write data and
uninitialized global variables (local variables will be allocated from the
stack, runtime-allocated memory is allocated from the heap).  Thus an executable
object may be split into four regions: \emph{code}, \emph{rodata} (constants),
\emph{rwdata} and \emph{dynamic data} (rwdata may also be implemented by copying
the initial data from rodata to dynamic data); stack and heap are
process-specific.

As many different processes may use the same executable objects, it would be a
waste of memory if the operating system created a copy of the object for each
reference to it.

Code and rodata may not be written to by a process, thus the operating system
can share these two regions among processes that are using the same objects
(binaries or libraries).  Thus, once an operating system \emph{ensures} that a
process can not write to code-regions and read-only data-regions, it can map
these once loaded regions into multiple virtual address spaces. This enforcement
is done in hardware, on IA-32 by setting a flag in the page directory or a page
table referencing the specific physical memory pages containing the region.

Newer CPUs provide \emph{page-level no-execute enforcements} (AMD's NX \emph{No
eXecute bit}, Intel's EXB \emph{EXecute disable Bit}); equal segment-level
enforcements exist for years but never have been used in mainstream as Linux and
many other operating-systems use a flat memory-model (with only one big segment
spanning the full virtual address space).  Once these page-level enforcements
are used in systems, attacks that inject code into data-regions or the stack are
rendered completely useless. However with access to the data-structures (page
directory and page tables) containing the information, which pages are
executable and which not, one can change this information before injecting code
e.g. into an applications stack. 

On Linux, programs and libraries are in \emph{Executable and Linker Format}
(ELF).  This format is roughly described in the manpage \texttt{elf(5)}. When a
binary is mapped into a process's memory, it is mapped including the full ELF
header containing all information that is required to link all references
between different objects; ELFs are always mapped at page-bounds. Due to this,
all mapped ELFs (that includes executables and libraries) can be found by
scanning all pages for the ELF Magic (0x7f E L F) at offset $0$ in the page.
Libraries, executables and other ELF objects can be distinguished by evaluating
the \texttt{e\_type} field of the ELF header.

\subsubsection{Overwriting executable or library code}

When code of executables or libraries is changed, all programs using these ELF
objects are influenced at the same time. An attacker thus has the ability, but
also the burden, to possibly infect several processes at the same time. Such an
attack has to be carefully prepared and conducted, as each system may have a
different version of a binary and overwriting the wrong parts of an ELF or
writing the wrong code may result in an almost immediate crash of all processes
using the ELF. Though this is a rather interesting approach, there are easier
ways to inject code into a \emph{single} process (see \ref{overwriting_stack}).

Such an attack could be conducted by searching a single virtual address space
for the glibc and then parsing the ELF-headers and searching for the entry-point
of the \texttt{printf}-function (or some other, less frequently used function).
Then a piece of code could be injected into the unused fragment of the last page
of the libc-mapping. It is important to inject the shellcode into the mapping,
as all processes that will be affected have to be able to reach the shellcode.
The intention is to overwrite the \texttt{printf} functions code with a
\emph{relative}\footnote{An ELF may be mapped at different locations in
different processes, if it is ``PIC'' or ``PIE'' (Position Independent
Code/Executable) and the kernel supports this.  Thus, unless the ELF is only
mapped in one process or the overwritten function is only used in one process,
the jumps target has to be addressed relative to the current position.} jump to
this injected code.  But as we need to overwrite some instructions inside the
function, we need to parse the functions code to separate each
instruction\footnote{on IA-32, different machine instructions can have different
length}, so that after our code is executed, it executes a copy of the
overwritten instructions and jumps to a fully intact instruction right after the
injected jump. After this has been done, the jump can be injected into the
functions code. This last write has to be as atomic as possible, as a process
may just be executing these bytes and thus get astray.  On IA-32, entry-points
of functions are most likely aligned to 32-bit addresses\footnote{due to
optimizations by the compiler}.  Firewire also provides an interface to write
32-bit aligned 32-bit values (``quads'') atomically.  Unfortunately, a
\emph{relative short} jump ($2$ bytes) can only jump within $\pm256$ bytes from
the jump itself and \emph{relative long} and \emph{absolute} jumps are $5$ bytes
wide ($1$ byte command + $4$ bytes address).  A short jump is most likely
incapable of reaching the last page of the ELF and writing a long relative jump
is not atomic.

A lot of interesting methods to inject code into a running process have been
developed; e.g.  \cite{phrack59.8:2002} gives an introduction into using
\emph{ptrace}, including injecting whole shared objects using the runtime linker
\emph{libdl}.  The usability of this approach has not yet been analysed.


\subsubsection{Overwriting the stack and return addresses}

\label{overwriting_stack} Besides stealing SSH-keys, I have put most of my
efforts into injecting code into the stack and overwriting return-addresses on
the stack to point to the injected code. This modification of the classic
\emph{stack overflow} method has some advantages over the previous approach:

\begin{itemize}

	\item Each process, even each thread, has its own stack. Thus only a
		single thread will be affected by the attack.

	\item If the attack fails and the thread dies, only a \emph{single}
		thread will fail on the target system, not e.g. \emph{all}
		processes using the glibc or \emph{all} instances of $/bin/sh$.

	\item The process can read and write to the stack as well, thus we can
		communicate with the injected shell-code in a rather easy way
		(see \ref{communication_DMA}).

	\item During the attack we do not need to modify parts of the code of
		the target-process, reducing the risk of an astray process. The
		final part consists of overwriting 4 byte wide return-addresses
		on the stack and this can almost always be done automatically.

\end{itemize}

The attack consists of the following steps:

\begin{enumerate}

	\item Search a free location in the stack-pages. If the shellcode is
		small, we can use the zero-padded area of the pages containing
		the environment and argument vectors (see section
		\ref{identifying_processes}). If the shellcode does not fit into
		this area, we could try to just overwrite these vectors. Most
		programs will parse environment and arguments only once during
		startup of the program, thus this should be rather safe.

	\item Scan the stack for stack-frames and for each found: overwrite the
		return address. This can be simplified into: overwrite all
		32-bit aligned 32-bit values that contain a value that might be
		a pointer into the main code area (\texttt{0x08**~****}, see
		figure \ref{fig:linux_virtual_address_space}) with a pointer to
		the injected code.  A more aggressive approach might also
		overwrite return-values pointing into the library section
		(\texttt{0xB7**~****}).

\end{enumerate}

Once the attacked process leaves a stack frame with an overwritten return value,
it will jump to the injected code and execute it.

An implementation of this attack, including some sample shellcodes like a
bindshell and a simple printf can be found in
\texttt{attacks/userspace/inject-code.c} and \linebreak
\texttt{attacks/userspace/shellcodes/}.

% FIXME: mehr infos zu ``3.1.1:Identifying processes'', danach hier darauf
% aufbauen. Mehr infos zu stack-frames?

\subsubsection{Direct communication with shellcode via DMA}

\label{communication_DMA} The masterpiece of shellcode-writing is a shellcode
that spawns an interactive shell (thus the name ``shellcode'') and yet is as
invisible on the target system as possible.  An interactive shell has to
communicate with its user, so typically a network-based bindshell is used for
this attack. The downside is the visibility of the communication on the
network-layer: an administrator can easily spot the network connection by either
sniffing on the network or by asking the system what kind of sockets and files a
process is using\footnote{e.g. by using \texttt{lsof -i} (LiSt Open Files)}. A
network intrusion system (NIS) can easily spot bindshell connections in an
automated way or firewalls could be configured in a way that a network
connection is impossible. When using e.g. firewire to attack a host it is even
possible that there is no network connection between the attacker and the victim
at all.

Obviously the bindshell approach is a suboptimal one, if there is no direct
network connection between attacker and victim. But if an attacker uses a
special media for his attack, he can also use this media for communicating with
his injected ``beachhead'', does he not?

So as we use DMA to inject shellcode, we can use DMA to communicate with the
shellcode. The overall mechanism is introduced in figure
\ref{fig:functionality_beachhead}. The injected shellcode will fork a shell and
communicate with stdin/stdout of the shell via two pipes. The shellcode then
creates a second thread, then having one thread for each direction of
\emph{master to shell} and \emph{shell to master}. If the master wishes to send
a command to the shell, it writes the command string into the \emph{FromMaster}
ring-buffer via DMA.  Once the ReaderThread sees that the ring-buffer is not
empty, it reads the data inside the buffer and writes it into the pipe to the
shell.  The WriterThread will read data coming from the shell from the pipe and
then write it into the \emph{ToMaster} ring-buffer, so the master can read it
via DMA.

The shellcode of the beachhead
(\texttt{attacks/userspace/shellcodes/dmashellcode.s}) is introduced in figure
\ref{fig:beachhead_pseudocode} in pseudo-code. The program to inject the
shellcode and communicate with it is \texttt{attacks/userspace/dmashell.c}.

\begin{figure}[ht] \begin{center}

	\epsfysize 6cm

	\epsffile{functionality_beachhead.eps}

	\caption{Functionality of the beachhead}

	\label{fig:functionality_beachhead}

\end{center}\end{figure}


\begin{figure}[htp] \begin{center} \tiny
	\begin{lstlisting}
		// ringbuffer for data from beachhead to master
		RingBuffer	ToMaster;
		// ringbuffer for data from master to beachhead
		RingBuffer	FromMaster;

		// pipe for data from beachhead to shell
		int		ToShell[2];
		// pipe for data from shell to beachhead
		int		FromShell[2];
		// flag, if pipes are still valid (volatile because two threads access it)
		volatile bool	pipes_ok = 1;

		int		child_pid;
		// set by master if child should be killed
		volatile bool	terminate_child = 0;
		// set by beachhead to signal death of child
		bool		child_is_dead = 0;
		// set by master to acknowledge death of child
		volatile bool	child_is_dead_ACK = 0;

		start:
			pipe(ToShell[]);
			pipe(FromShell[]);
			switch fork() {
				case child:
					dup2(ToShell[0], stdin);
					dup2(FromShell[1], stdout);
					dup2(FromShell[1], stderr);
					execve("/bin/sh");
					// on failure: exit.
					exit();
					;;
				case parent:
					child_pid = returnvalue of fork;
					close(ToShell[0]);
					close(FromShell[1]);
					// create a second thread "WriterThread"
					clone(WriterThread);
					// current thread becomes "ReaderThread"
					goto ReaderThread;
					;;
			}


		ReaderThread:
			// the ReaderThread will read from the master and relay to the shell
			while( pipes_ok ) {
				if(terminate_child) {
					// attacker requested shell to be terminated
					kill(child_pid, SIGKILL);
					pipes_ok = 0;
					// ReaderThread terminates, WriterThread will do cleanup
					exit();
				}
				if( isEmpty(FromMaster) ) {
					sleep(0.001 seconds);
				} else {
					if(1 != write(ToShell[1], FromMaster.buffer
							+FromMaster.currentLocation, 1 byte)) {
						// can not communicate with child
						pipes_ok = 0;
					} else
						FromMaster.currentLocation += 1;
				}
			}
			exit();

		WriterThread:
			// the WriterThread will read from the shell and relay to the master
			while( pipes_ok ) {
				if( isFull(ToMaster) ) {
					sleep(0.001 seconds);
				} else {
					if(1 != read(FromShell[0], ToMaster.buffer
							+ToMaster.currentLocation, 1 byte)) {
						// can not communicate with child
						pipes_ok = 0;
					} else
						ToMaster.currentLocation += 1;
				}
			}
			// pipes are closed. tell the master, but wait at most 2 seconds
			while(!chils_is_dead_ACK && child_is_dead <= 2) {
				child_is_dead++;
				sleep(1 second);
			}
			exit();
			

	\end{lstlisting}
	\caption{Beachhead shellcode (\texttt{dmashellcode.s}), pseudocode}
	\label{fig:beachhead_pseudocode}
\end{center} \end{figure}

