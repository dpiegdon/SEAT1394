% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Attack vectors}




\subsection{Information Gathering}

\subsubsection{Identifying processes}

Once an address translation table has been found, the question is: what kind of
process resides in this virtual address space?

For userspace applications on IA32-linux there is a simple way to identify a
process's \emph{filename}, its \emph{command line arguments} and even its full
set of \emph{environment variables}: All this information is often required by a
process and thus the kernel will provide it to the process by copying it to the
stacks bottom pages, i.e.  the stack-pages that are found first when seeking
from \texttt{0xbfff~f000} downward.

FIXME FIXME

\subsubsection{Typical places to find secrets}

Many applications keep secrets in their memory, some of them even locking them
into the main memory\footnote{e.g. via the \emph{mlock} function} to prevent the
operating system from swapping them to slower media. ``Secrets'' includes, among
other information, \emph{authentication data}, \emph{cryptographic key
material}, \emph{random data} (e.g. to seed a cryptographic algorithm) and
sometimes even \emph{algorithms} (\emph{proprietary software}). Authentication
data can be e.g.  passwords or private keys for signature algorithms;
cryptographic key material, as the name says, are keys for usage with
cryptographic algorithms (like the above signature algorithms). These two will
be of main interest in this section.

Many applications using a cryptographic infrastructure for communications will
keep once loaded passwords or keys in their main memory for successive usage.
The operating systems protection model ensures the safety of this information
from other processes running on the same system; but by accessing the main
memory we do have full access to this material. The only task that remains is to
reconstruct the key material and passwords from the memory.

As an example, the following applications are of interest:

\begin{itemize}

	\item GnuPG and PGP: applications to sign and encrypt arbitrary data
	with public/private keypairs. They are wide spread for email-encryption
	and -signing.

	\item sshd, ssh and ssh-agent: the \emph{secure shell} application is an
	extended, encrypted version of telnet using strong cryptography,
	including passwords, skey, x509 certificates, RSA and DSA keys.

	\item Apache and other SSL-enabled web servers.

	\item OpenVPN, Cisco-VPN and other VPN-servers and clients

	\item Instant Messaging Applications, e.g. Psi keeps the authentication
	information and possibly the GnuPG keypair in memory.

	\item The computer BIOS or PGP-Wholedisk: the computer can be locked
	with a BIOS password or the harddisk can be encrypted. For a sample
	attack, see \cite{rux2k6firewire:2006}.

\end{itemize}


\subsubsection{Example attack: ssh-agent snarfer}

\label{ssh-agent-snarfer} To proof that it is rather easy to obtain secret keys
from a process I have written a sample attack to obtain \emph{ssh public/private
keypairs} from \texttt{ssh-agent}s via \emph{firewire}.

When using \texttt{ssh} for accessing remote computers it is possible to
authenticate via passwords, public/private keypairs and various other methods.
The usage of public/private keypairs is wide-spread among people using
\texttt{ssh} on a regular basis. These keypairs can either be a DSA or a RSA
keypair, they are typically created with \texttt{ssh-keygen} and stored
somewhere in \texttt{\$HOME/.ssh/}, e.g.  \texttt{/root/.ssh/id\_dsa} and
\texttt{/root/.ssh/id\_dsa.pub}. Keypairs can and should be encrypted with a
passphrase to prevent attackers from using them, if they were able to obtain
them somehow. Thus to use a keypair it is required to enter this passphrase each
time. This can be disturbing during frequent usage, e.g. when using
\texttt{ssh+svn} or \texttt{scp} with remote-tab-completition (\texttt{zsh} is
capable of this).

For these and other reasons, the \texttt{ssh-agent} has been developed. This
agent will run in the background; the user can store a keypair into it (once
entering the passphrase to unlock the keypair) and successively use the keypair
without the requirement to enter the passphrase each time. The keypair can be
wiped from memory on demand and also be loaded only for a specified period of
time.

Actually, here begins the fun. During my tests I found that the key is
\emph{not} wiped from memory when the timelimit is hit. It will be wiped the
next time the ssh-agent is queried (via its socket), but the agent is stalled in
a \emph{read}-systemcall until this query and thus can not wipe the key. That
makes it possible to obtain long overdue keys from \texttt{ssh-agent}s, although
their owners believed them to be safe. A simple timer could have prevented this
-- I hereby strongly encourage the developers to implement such a timer. But
even with such a time enabled it would be possible to acquire the key during its
lifetime.

To obtain a keypair from an agent via firewire, a staged attack is required:

\begin{enumerate}

	\item Seek the first GiB of physical memory for pagetables.

	\item For each pagetable: check, if the found userspace belongs to a
	\texttt{ssh-agent} process. If not, seek next pagetable.

	\item Construct a possible path where the keypair may reside in the
	filesystem (e.g. ``\texttt{/home/lostrace/.ssh/}'') and seek this string
	in the heap. This will only find keypairs that have been loaded with
	this keylocation. Actually this field is the key's comment-field that is
	mostly unused and overwritten with the filename of the key. \\ Keypairs
	loaded from different locations or via a relative path or with set
	comment-fields can thus not be found by this search.
	
	\item This string is pointed to by the \emph{identity}-struct, that also
	contains a pointer to a \emph{KEY}-struct. To find the
	\emph{identity}-struct, one has to seek the address of the above string
	in the heap. \emph{Each} loaded keypair has one \emph{identity}-struct
	and can be found by searching its comment field in the full heap and
	then searching its address in the heap. (The search algorithm (2,3,4) is
	far from perfect but works rather well. To create a better algorithm
	remains as an exercise to the interested reader.)
	
	\item Once the \emph{KEY}-struct has been found, the reconstruction to a
	local copy consists of a lot of memory-jumping, pointer arithmetics and
	alike, but is fully implemented for both DSA and RSA keypairs by now.

	\item Save each found keypair to a file.
	
\end{enumerate}

As stated above, the keypairs reside decrypted in the memory of the agent (even
if overtime) and thus, when stored to a file, can be immediately used by the
command \texttt{ssh~-i~keyfile~user@host}~.  Such an attack will not take much
longer than searching the first 1 GiB of physical RAM for pagedirectories, that
is \emph{typically no more than 15 seconds}. If an attack fails but an agent was
found, it would be possible to just dump the heap of the agent and stage a more
thorough attack at a later time. Once the heap is dumped, all required data is
obtained. A similar attack via \emph{ptrace} should be possible as well.

The reader may refer to \texttt{attacks/userspace/snarf-sshkey.c} in the
corresponding tarball for the source-code of the attack. As the attack dumps the
key in a format directly usable by \texttt{ssh} is is required to link against
\texttt{libssh.a}, which is part of \emph{openssh}. Because of this, it is
required to have a \texttt{./configure}d \emph{openssh}-source in
\texttt{attacks/userspace/openssh/} to compile the snarfer. Please also keep in
mind that this attack will only find keys \emph{without comment-fields} and
loaded with the absolute path \texttt{\$HOME/.ssh/}.

\subsubsection{Matching and statistics to find secret keys}




\subsection{Userspace Modifications}

\subsubsection{Overwriting process code}

\subsubsection{Overwriting library code}

\subsubsection{Overwriting stack and return addresses}




\subsection{Kernelspace Modifications}

\subsubsection{Emulating \texttt{/dev/kmem}}

\subsubsection{Resolving kernel addresses}





\subsection{Bootstrapping custom operating systems}



