% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Attacking}




\subsection{Information Gathering}

\subsubsection{Identifying processes}

Once an address translation table has been found, it is of interest, what kind
of process resides in this virtual address space.  For userspace applications on
IA32-linux there is a simple way to identify a process's \emph{filename}, its
\emph{arguments} and even its full set of \emph{environment variables}: This
information is often required by a process and thus the kernel will provide it
to the process by copying it to the bottom pages of the application's
stack\footnote{i.e.  the stack-pages that are found first when seeking downward
from \texttt{0xbfff~f000}}.

\texttt{proc\_info()} will seek the stack-bottom, parse it and return
ready-for-use environment vectors, command-line vectors and the full path of the
binary for a given linear address space. \texttt{remote-ps}, located in
\texttt{attacks/information/}, uses \texttt{proc\_info()} for each found address
space and will print a list of all found processes with its arguments.


\subsubsection{Typical places to find secrets}

Many applications keep secrets in their memory, some of them even locking them
into the main memory\footnote{e.g. via the \emph{mlock} function} to prevent the
operating system from swapping them to slower media. ``Secrets'' includes, among
other information, \emph{authentication data}, \emph{cryptographic key
material}, \emph{random data} (e.g. to seed a cryptographic algorithm) and
sometimes even \emph{algorithms} (\emph{proprietary software}). Authentication
data can be e.g.  passwords or private keys for signature algorithms;
cryptographic key material, as the name says, are keys for usage with
cryptographic algorithms (like the above signature algorithms). These two will
be of main interest in this section.

Many applications using a cryptographic infrastructure for communications will
keep once loaded passwords or keys in their main memory for successive usage.
The operating systems protection model ensures the safety of this information
from other processes running on the same system; but by accessing the main
memory we do have full access to this material. The only task that remains is to
reconstruct the key material and passwords from the memory.

As an example, the following applications are of interest:

\begin{itemize}

	\item GnuPG and PGP: applications to sign and encrypt arbitrary data
	with public/private keypairs. They are wide spread for email-encryption
	and -signing.

	\item sshd, ssh and ssh-agent: the \emph{secure shell} application is an
	extended, encrypted version of telnet using strong cryptography,
	including passwords, skey, x509 certificates, RSA and DSA keys.

	\item Apache and other SSL-enabled web servers.

	\item OpenVPN, Cisco-VPN and other VPN-servers and clients

	\item Instant Messaging Applications, e.g. Psi keeps the authentication
	information and possibly the GnuPG keypair in memory.

	\item The computer BIOS or PGP-Wholedisk: the computer can be locked
	with a BIOS password or the harddisk can be encrypted. For a sample
	attack, see \cite{rux2k6firewire:2006}.

\end{itemize}


\subsubsection{Example attack: ssh-agent snarfer}

\label{ssh-agent-snarfer} To proof that it is rather easy to obtain secret keys
from a process I have written a sample attack to obtain \emph{ssh public/private
keypairs} from \texttt{ssh-agent}s via \emph{firewire}.

When using \texttt{ssh} for accessing remote computers it is possible to
authenticate via passwords, public/private keypairs and various other methods.
The usage of public/private keypairs is wide-spread among people using
\texttt{ssh} on a regular basis. These keypairs can either be a DSA or a RSA
keypair, they are typically created with \texttt{ssh-keygen} and stored
somewhere in \texttt{\$HOME/.ssh/}, e.g.  \texttt{/root/.ssh/id\_dsa} and
\texttt{/root/.ssh/id\_dsa.pub}. Keypairs can and should be encrypted with a
passphrase to prevent attackers from using them, if they were able to obtain
them somehow. Thus to use a keypair it is required to enter this passphrase each
time. This can be disturbing during frequent usage, e.g. when using
\texttt{ssh+svn} or \texttt{scp} with remote-tab-completition (\texttt{zsh} is
capable of this).

For these and other reasons, the \texttt{ssh-agent} has been developed. This
agent will run in the background; the user can store a keypair into it (once
entering the passphrase to unlock the keypair) and successively use the keypair
without the requirement to enter the passphrase each time. The keypair can be
wiped from memory on demand and also be loaded only for a specified period of
time.

Actually, here begins the fun. During my tests I found that the key is
\emph{not} wiped from memory when the timelimit is hit. It will be wiped the
next time the ssh-agent is queried (via its socket), but the agent is stalled in
a \emph{read}-systemcall until this query and thus can not wipe the key. That
makes it possible to obtain long overdue keys from \texttt{ssh-agent}s, although
their owners believed them to be safe. A simple timer could have prevented this
-- I hereby strongly encourage the developers to implement such a timer. But
even with such a time enabled it would be possible to acquire the key during its
lifetime.

To obtain a keypair from an agent via firewire, a staged attack is required:

\begin{enumerate}

	\item Seek the first GiB of physical memory for pagetables.

	\item For each pagetable: check, if the found userspace belongs to a
	\texttt{ssh-agent} process. If not, seek next pagetable.

	\item Construct a possible path where the keypair may reside in the
	filesystem (e.g. ``\texttt{/home/lostrace/.ssh/}'') and seek this string
	in the heap. This will only find keypairs that have been loaded with
	this keylocation. Actually this field is the key's comment-field that is
	mostly unused and overwritten with the filename of the key. \\ Keypairs
	loaded from different locations or via a relative path or with set
	comment-fields can thus not be found by this search.
	
	\item This string is pointed to by the \emph{identity}-struct, that also
	contains a pointer to a \emph{KEY}-struct. To find the
	\emph{identity}-struct, one has to seek the address of the above string
	in the heap. \emph{Each} loaded keypair has one \emph{identity}-struct
	and can be found by searching its comment field in the full heap and
	then searching its address in the heap.
	
	\item Once the \emph{KEY}-struct has been found, the reconstruction to a
	local copy consists of a lot of memory-jumping, pointer arithmetics and
	alike, but is fully implemented for both DSA and RSA keypairs by now.

	\item Save each found keypair to a file.
	
\end{enumerate}
	
The search algorithm (2,3,4) is far from perfect but works rather well.  To
create a better algorithm remains as an exercise to the interested reader. For
instance, a much better algorithm to find the \emph{identity}-structs is to use
the ELF-headers of the mapped executable to resolve the symbol of the
\emph{idtable}\footnote{the \emph{idtable} is a structure holding all keys that
are loaded into the agent}. This approach is straight-forward, hits \emph{all}
keys and would have worked almost always, if not many (almost all) distributions
distributed programs with stripped symbols to reduce their size; this
invalidates the symbol-resolution-approach, as this stripping also removes any
information of the \emph{idtable} symbol.

Furthermore once \emph{one} \emph{identity}-struct is found, \emph{all} structs
of the same keytype (RSA or DSA) could be found by walking the list this key is
linked into.

As stated above, the keypairs reside decrypted in the memory of the agent (even
if overtime) and thus, when stored to a file, can be immediately used by the
command \texttt{ssh~-i~keyfile~user@host}~.  Such an attack will not take much
longer than searching the first 1 GiB of physical RAM for pagedirectories, that
is \emph{typically no more than 15 seconds}. If an attack fails but an agent was
found, it would be possible to just dump the heap of the agent and stage a more
thorough attack at a later time. Once the heap is dumped, all required data is
obtained. A similar attack via \emph{ptrace} should be possible as well.

The reader may refer to \texttt{attacks/information/snarf-sshkey.c} in the
corresponding tarball for the source-code of the attack. Please keep in mind
that this attack will only find keys loaded with the absolute path
\texttt{\$HOME/.ssh/}.


\subsubsection{Matching and statistics to find secret keys}

\cite{hide_n_seek:1998} introduces some schemes to find secret keys in random
data and some countermeasures. It takes a special look at finding private RSA
keys if their corresponding public keys are known and finding keys by searching
high-entropy regions. Though I encourage the reader to read this interesting
paper, the circumstances are most likely very different now: cheap and small
storage media like flash-memory and small harddisks have increased portable
storage to a huge size, equal or larger than the memory a computer system
typically has. Thus, an attacker can just dump the full memory or a subset of it
(like the virtual address space of a single process) that is promising to
contain a secret. A thorough attack can then be staged later.  Still, searching
private keys with the introduced methods can be very helpful, if reconstruction
of the used data-structures is impossible or more expensive. Furthermore, when
trying to obtain a private key, often enough the corresponding public key is
unknown. This invalidates the approaches introduced to find RSA secret keys that
require the public key.




\subsection{Userspace Modifications}

\subsubsection{Overwriting process code}

\subsubsection{Overwriting library code}

\subsubsection{Overwriting stack and return addresses}




\subsection{Kernelspace Modifications}

\subsubsection{Emulating \texttt{/dev/kmem}}

\subsubsection{Resolving kernel addresses}





\subsection{Bootstrapping custom operating systems}



