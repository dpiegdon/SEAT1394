% vim: tw=80 ai fdl=99 fo+=a
%
% $Id$
%

\section{Attacking}




\subsection{Information Gathering}

\subsubsection{Identifying processes}

Once an address translation table has been found, it is of interest, what kind
of process resides in this virtual address space.  For userspace applications on
IA32-linux there is a simple way to identify a process's \emph{filename}, its
\emph{arguments} and even its full set of \emph{environment variables}: This
information is often required by a process and thus the kernel will provide it
to the process by copying it to the bottom pages of the application's
stack\footnote{i.e.  the stack-pages that are found first when seeking downward
from virtual address \texttt{0xbfff~f000}}.

\texttt{proc\_info()} will seek the stack-bottom, parse it and return
ready-for-use environment vectors, command-line vectors and the full path of the
binary for a given linear address space. \texttt{remote-ps}, located in
\texttt{attacks/information/}, uses \texttt{proc\_info()} for each found address
space and will print a list of all found processes with its arguments.


\subsubsection{Typical places to find secrets}

Many applications keep secrets in their memory, some of them even locking them
into the main memory\footnote{e.g. via the \emph{mlock} function} to prevent the
operating system from swapping them to slower media. ``Secrets'' includes, among
other information, \emph{authentication data}, \emph{cryptographic key
material}, \emph{random data} (e.g. to seed a cryptographic algorithm) and
sometimes even \emph{algorithms} (\emph{proprietary software}). Authentication
data can be e.g.  passwords or private keys for signature algorithms;
cryptographic key material, as the name says, are keys for usage with
cryptographic algorithms (like the above signature algorithms). These two will
be of main interest in this section.

Many applications using a cryptographic infrastructure for communications will
keep once loaded passwords or keys in their main memory for successive usage.
The operating systems protection model ensures the safety of this information
from other processes running on the same system; but by accessing the main
memory we do have full access to this material. The only task that remains is to
reconstruct the key material and passwords from the memory.

As an example, the following applications are of interest:

\begin{itemize}

	\item GnuPG and PGP: applications to sign and encrypt arbitrary data
	with public/private keypairs. They are wide spread for email-encryption
	and -signing.

	\item sshd, ssh and ssh-agent: the \emph{secure shell} application is an
	extended, encrypted version of telnet using strong cryptography,
	including passwords, skey, x509 certificates, RSA and DSA keys.

	\item Apache and other SSL-enabled web servers.

	\item OpenVPN, Cisco-VPN and other VPN-servers and clients

	\item Instant Messaging Applications, e.g. Psi keeps the authentication
	information and possibly the GnuPG keypair in memory.

	\item The computer BIOS or PGP-Wholedisk: the computer can be locked
	with a BIOS password or the harddisk can be encrypted. For a sample
	attack, see \cite{rux2k6firewire:2006}.

\end{itemize}


\subsubsection{Example attack: ssh-agent snarfer}

\label{ssh-agent-snarfer} To proof that it is rather easy to obtain secret keys
from a process I have written a sample attack to obtain \emph{ssh public/private
keypairs} from \texttt{ssh-agent}s via \emph{firewire}.

When using \texttt{ssh} for accessing remote computers it is possible to
authenticate via passwords, public/private keypairs and various other methods.
The usage of public/private keypairs is wide-spread among people using
\texttt{ssh} on a regular basis. These keypairs can either be a DSA or a RSA
keypair, they are typically created with \texttt{ssh-keygen} and stored
somewhere in \texttt{\$HOME/.ssh/}, e.g.  \texttt{/root/.ssh/id\_dsa} and
\texttt{/root/.ssh/id\_dsa.pub}. Keypairs can and should be encrypted with a
passphrase to prevent attackers from using them, if they were able to obtain
them somehow. Thus to use a keypair it is required to enter this passphrase each
time. This can be disturbing during frequent usage, e.g. when using
\texttt{ssh+svn} or \texttt{scp} with remote-tab-completition (\texttt{zsh} is
capable of this).

For these and other reasons, the \texttt{ssh-agent} has been developed. This
agent will run in the background; the user can store a keypair into it (once
entering the passphrase to unlock the keypair) and successively use the keypair
without the requirement to enter the passphrase each time. The keypair can be
wiped from memory on demand and also be loaded only for a specified period of
time.

Actually, here begins the fun. During my tests I found that the key is
\emph{not} wiped from memory when the timelimit is hit. It will be wiped the
next time the ssh-agent is queried (via its socket), but the agent is stalled in
a \emph{read}-systemcall until this query and thus can not wipe the key. That
makes it possible to obtain long overdue keys from \texttt{ssh-agent}s, although
their owners believed them to be safe. A simple timer could have prevented this
-- I hereby strongly encourage the developers to implement such a timer. But
even with such a time enabled it would be possible to acquire the key during its
lifetime.

To obtain a keypair from an agent via firewire, a staged attack is required:

\begin{enumerate}

	\item Seek the first GiB of physical memory for pagetables.

	\item For each pagetable: check with the introduced
	\texttt{proc\_info()}, if the found userspace belongs to a
	\texttt{ssh-agent} process. If not, seek next pagetable.

	\item Use the obtained environment to resolve the users homedirectory
	(\texttt{\$HOME}) and construct a path where keypairs most likely reside
	in the filesystem (e.g.  ``\texttt{\$HOME/.ssh/}'') and seek this string
	in the heap.  This approach will only find keypairs that have been
	loaded with this keylocation.\footnote{Actually this field is the key's
	comment-field that is mostly unused and overwritten with the filename of
	the key. Keypairs that are used with SSH protocol version 2 (virtually
	all) do not have a comment-field; during loading, the comment-field is
	always initialized with the keys pathname.} Keypairs loaded from
	different locations or via a relative path can thus not be found by this
	search.
	
	\item All loaded keypairs have a corresponding
	\emph{identity-struct}\footnote{\texttt{struct identity} is defined in
	\texttt{openssh/ssh-agent.c}} in an agent. Among other fields, this
	identity-struct contains a link to a key struct, the above mentioned
	path/comment-field and the lifetime of the key. Thus to find the
	identity struct corresponding to a found comment-field, one has to
	search the address of the comment-field in the heap of the agent.
	
	\item Once the \emph{key-struct}\footnote{\texttt{struct key} is defined
	in \texttt{openssh/key.h}} that is linked to by the identity-struct has
	been found, one can determine wheather the found key is a RSA or a DSA
	key.  The key-struct contains a type-field and two pointers to either
	the RSA or the DSA key. These referenced structures are the
	\emph{openssl}\footnote{OpenSSL is a free open-source implementation of
	the secure socket layer protocol also providing a general purpose
	cryptography library (\text{libcrypto}).}-structures \texttt{RSA} and
	\texttt{DSA}.
	
	\item For both RSA and DSA structures, all important fields need to be
	recovered to obtain valid keypairs. \cite{applied_crypto:1996,
	handbook_applied_crypto:2001} give an overview of both cryptographic
	algorithms, \cite{openssl_book:2002} introduces openssl concepts and
	implementation details. Openssl's arbitrary precision integer
	implementation is the \texttt{BIGNUM}-struct. It consists of a
	variable-length array of bit-vectors forming the value and a
	length-field defining the length of this array. As RSA and DSA both
	operate on finite fields, both are implemented with \texttt{BIGNUM}s.
	Therefore, the RSA and DSA structures contain several \texttt{BIGNUM}s
	that need to be recovered to obtain a valid copy of the keypair.

	\item Some validity tests may be done to verify that the acquired
	\texttt{BIGNUM}s fulfill algorithm-specific properties\footnote{During
	development it was useful to test obtained keys for some properties that
	are required. These tests are implemented in
	\texttt{attacks/information/sshkey-sanitychecks.c}} and thus form a
	valid keypair.

	\item Attach the obtained \texttt{BIGNUM}s back into valid RSA or DSA
	structures and save these keys to a file using openssl-functions.
	
\end{enumerate}
	
The search algorithm (2,3,4) is far from perfect but works rather well.  To
create a better algorithm remains as an exercise to the interested reader. For
instance, a much better algorithm to find the \emph{identity}-structs is to use
the ELF-headers of the mapped executable to resolve the symbol of the
\emph{idtable}\footnote{The \emph{idtable} is a structure holding all keys that
are loaded into the agent.}. This approach is straight-forward, hits \emph{all}
keys and would have worked almost always, if not many (almost all) distributions
distributed programs with their symbols stripped (due to size and security
reasons); this invalidates the symbol-resolution-approach, as this stripping
also removes any information of the \emph{idtable} symbol.

Furthermore once \emph{one} \emph{identity}-struct is found, \emph{all} structs
of the same keytype (RSA or DSA) could be found by walking the list this key is
linked into.

As stated above, the keypairs reside decrypted in the memory of the agent (even
if overtime) and thus, when snarfed and stored to a file, can be immediately
used by the command \texttt{ssh~-i~keyfile~user@host}~.  Such an attack will not
take much longer than searching the first 1 GiB of physical RAM for
pagedirectories, that is \emph{typically no more than 15 seconds}. If an attack
fails but an agent was found, it would be possible to just dump the heap of the
agent and stage a more thorough attack at a later time. Once the heap is dumped,
all required data is obtained. A similar attack via \emph{ptrace} should be
possible as well.

The reader may refer to \texttt{attacks/information/snarf-sshkey.c} in the
corresponding tarball for the source-code of the attack. Please keep in mind
that this attack will only find keys loaded with the absolute path
\texttt{\$HOME/.ssh/}.


\subsubsection{Matching and statistics to find secret keys}

\cite{hide_n_seek:1998} introduces some schemes to find secret keys in random
data and some countermeasures. It takes a special look at finding private RSA
keys if their corresponding public keys are known and finding keys by searching
high-entropy regions. Though I encourage the reader to read this interesting
paper, the circumstances are most likely very different now: cheap and small
storage media like flash-memory and small harddisks have increased portable
storage to a huge size, equal or larger than the memory a computer system
typically has. Thus, an attacker can just dump the full memory or a subset of it
(like the virtual address space of a single process) that is promising to
contain a secret. A thorough attack can then be staged later.  Still, searching
private keys with the introduced methods can be very helpful, if reconstruction
of the used data-structures is impossible or more expensive. Furthermore, when
trying to obtain a private key, often enough the corresponding public key is
unknown. This invalidates the approaches introduced to find RSA secret keys that
require the public key.




\subsection{Userspace Modifications}

\subsubsection{Overwriting process code}

\subsubsection{Overwriting library code}

\subsubsection{Overwriting stack and return addresses}




\subsection{Kernelspace Modifications}

\subsubsection{Emulating \texttt{/dev/kmem}}

\subsubsection{Resolving kernel addresses}





\subsection{Bootstrapping custom operating systems}



